
EncoderTR_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  00000c8a  00000d1e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000c8a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001b0  0080010c  0080010c  00000d2a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d2a  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000001b0  00000000  00000000  00000d5a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000012f6  00000000  00000000  00000f0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000860  00000000  00000000  00002200  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a6d  00000000  00000000  00002a60  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000004a4  00000000  00000000  000034d0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000498  00000000  00000000  00003974  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001676  00000000  00000000  00003e0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000150  00000000  00000000  00005482  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 ae 00 	jmp	0x15c	; 0x15c <__ctors_end>
   4:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
   8:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
   c:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  10:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  14:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  18:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  1c:	0c 94 c0 05 	jmp	0xb80	; 0xb80 <__vector_7>
  20:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  24:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  28:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  2c:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  30:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  34:	0c 94 ef 01 	jmp	0x3de	; 0x3de <__vector_13>
  38:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  3c:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  40:	0c 94 3c 04 	jmp	0x878	; 0x878 <__vector_16>
  44:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  48:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  4c:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  50:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  54:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  58:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  5c:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  60:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  64:	0c 94 cb 00 	jmp	0x196	; 0x196 <__bad_interrupt>
  68:	54 03       	mulsu	r21, r20
  6a:	a2 03       	fmuls	r18, r18
  6c:	56 03       	mulsu	r21, r22
  6e:	58 03       	fmul	r21, r16
  70:	5a 03       	fmul	r21, r18
  72:	5c 03       	fmul	r21, r20
  74:	5e 03       	fmul	r21, r22
  76:	60 03       	mulsu	r22, r16
  78:	62 03       	mulsu	r22, r18
  7a:	64 03       	mulsu	r22, r20
  7c:	66 03       	mulsu	r22, r22
  7e:	68 03       	fmul	r22, r16
  80:	6a 03       	fmul	r22, r18
  82:	6e 03       	fmul	r22, r22
  84:	70 03       	mulsu	r23, r16
  86:	74 03       	mulsu	r23, r20
  88:	a0 03       	fmuls	r18, r16
  8a:	a0 03       	fmuls	r18, r16
  8c:	a0 03       	fmuls	r18, r16
  8e:	a0 03       	fmuls	r18, r16
  90:	a0 03       	fmuls	r18, r16
  92:	a0 03       	fmuls	r18, r16
  94:	a0 03       	fmuls	r18, r16
  96:	a0 03       	fmuls	r18, r16
  98:	a0 03       	fmuls	r18, r16
  9a:	a0 03       	fmuls	r18, r16
  9c:	a0 03       	fmuls	r18, r16
  9e:	a0 03       	fmuls	r18, r16
  a0:	a0 03       	fmuls	r18, r16
  a2:	a0 03       	fmuls	r18, r16
  a4:	a0 03       	fmuls	r18, r16
  a6:	a0 03       	fmuls	r18, r16
  a8:	a0 03       	fmuls	r18, r16
  aa:	a0 03       	fmuls	r18, r16
  ac:	9a 03       	fmulsu	r17, r18
  ae:	a0 03       	fmuls	r18, r16
  b0:	a0 03       	fmuls	r18, r16
  b2:	a0 03       	fmuls	r18, r16
  b4:	a0 03       	fmuls	r18, r16
  b6:	9c 03       	fmulsu	r17, r20
  b8:	a0 03       	fmuls	r18, r16
  ba:	a0 03       	fmuls	r18, r16
  bc:	a0 03       	fmuls	r18, r16
  be:	a0 03       	fmuls	r18, r16
  c0:	a0 03       	fmuls	r18, r16
  c2:	98 03       	fmulsu	r17, r16
  c4:	a0 03       	fmuls	r18, r16
  c6:	a0 03       	fmuls	r18, r16
  c8:	54 03       	mulsu	r21, r20
  ca:	a2 03       	fmuls	r18, r18
  cc:	56 03       	mulsu	r21, r22
  ce:	58 03       	fmul	r21, r16
  d0:	5a 03       	fmul	r21, r18
  d2:	5c 03       	fmul	r21, r20
  d4:	5e 03       	fmul	r21, r22
  d6:	60 03       	mulsu	r22, r16
  d8:	62 03       	mulsu	r22, r18
  da:	64 03       	mulsu	r22, r20
  dc:	a0 03       	fmuls	r18, r16
  de:	a0 03       	fmuls	r18, r16
  e0:	a0 03       	fmuls	r18, r16
  e2:	a0 03       	fmuls	r18, r16
  e4:	a0 03       	fmuls	r18, r16
  e6:	a0 03       	fmuls	r18, r16
  e8:	a0 03       	fmuls	r18, r16
  ea:	66 03       	mulsu	r22, r22
  ec:	68 03       	fmul	r22, r16
  ee:	6a 03       	fmul	r22, r18
  f0:	6e 03       	fmul	r22, r22
  f2:	70 03       	mulsu	r23, r16
  f4:	74 03       	mulsu	r23, r20
  f6:	76 03       	mulsu	r23, r22
  f8:	78 03       	fmul	r23, r16
  fa:	a2 03       	fmuls	r18, r18
  fc:	7c 03       	fmul	r23, r20
  fe:	a0 03       	fmuls	r18, r16
 100:	7e 03       	fmul	r23, r22
 102:	80 03       	fmuls	r16, r16
 104:	82 03       	fmuls	r16, r18
 106:	54 03       	mulsu	r21, r20
 108:	86 03       	fmuls	r16, r22
 10a:	88 03       	fmulsu	r16, r16
 10c:	8a 03       	fmulsu	r16, r18
 10e:	5c 03       	fmul	r21, r20
 110:	8c 03       	fmulsu	r16, r20
 112:	8e 03       	fmulsu	r16, r22
 114:	92 03       	fmuls	r17, r18
 116:	94 03       	fmuls	r17, r20
 118:	a0 03       	fmuls	r18, r16
 11a:	96 03       	fmuls	r17, r22
 11c:	a0 03       	fmuls	r18, r16
 11e:	a0 03       	fmuls	r18, r16
 120:	a0 03       	fmuls	r18, r16
 122:	a0 03       	fmuls	r18, r16
 124:	a0 03       	fmuls	r18, r16
 126:	9e 03       	fmulsu	r17, r22
 128:	a0 03       	fmuls	r18, r16
 12a:	66 03       	mulsu	r22, r22
 12c:	68 03       	fmul	r22, r16
 12e:	6c 03       	fmul	r22, r20
 130:	6e 03       	fmul	r22, r22
 132:	72 03       	mulsu	r23, r18
 134:	74 03       	mulsu	r23, r20
 136:	64 03       	mulsu	r22, r20
 138:	7a 03       	fmul	r23, r18
 13a:	a2 03       	fmuls	r18, r18
 13c:	7c 03       	fmul	r23, r20
 13e:	a0 03       	fmuls	r18, r16
 140:	a2 03       	fmuls	r18, r18
 142:	80 03       	fmuls	r16, r16
 144:	82 03       	fmuls	r16, r18
 146:	84 03       	fmuls	r16, r20
 148:	86 03       	fmuls	r16, r22
 14a:	88 03       	fmulsu	r16, r16
 14c:	8a 03       	fmulsu	r16, r18
 14e:	5c 03       	fmul	r21, r20
 150:	8c 03       	fmulsu	r16, r20
 152:	90 03       	fmuls	r17, r16
 154:	92 03       	fmuls	r17, r18
 156:	94 03       	fmuls	r17, r20
 158:	a0 03       	fmuls	r18, r16
 15a:	96 03       	fmuls	r17, r22

0000015c <__ctors_end>:
 15c:	11 24       	eor	r1, r1
 15e:	1f be       	out	0x3f, r1	; 63
 160:	cf ef       	ldi	r28, 0xFF	; 255
 162:	d8 e0       	ldi	r29, 0x08	; 8
 164:	de bf       	out	0x3e, r29	; 62
 166:	cd bf       	out	0x3d, r28	; 61

00000168 <__do_copy_data>:
 168:	11 e0       	ldi	r17, 0x01	; 1
 16a:	a0 e0       	ldi	r26, 0x00	; 0
 16c:	b1 e0       	ldi	r27, 0x01	; 1
 16e:	ea e8       	ldi	r30, 0x8A	; 138
 170:	fc e0       	ldi	r31, 0x0C	; 12
 172:	02 c0       	rjmp	.+4      	; 0x178 <__do_copy_data+0x10>
 174:	05 90       	lpm	r0, Z+
 176:	0d 92       	st	X+, r0
 178:	ac 30       	cpi	r26, 0x0C	; 12
 17a:	b1 07       	cpc	r27, r17
 17c:	d9 f7       	brne	.-10     	; 0x174 <__do_copy_data+0xc>

0000017e <__do_clear_bss>:
 17e:	22 e0       	ldi	r18, 0x02	; 2
 180:	ac e0       	ldi	r26, 0x0C	; 12
 182:	b1 e0       	ldi	r27, 0x01	; 1
 184:	01 c0       	rjmp	.+2      	; 0x188 <.do_clear_bss_start>

00000186 <.do_clear_bss_loop>:
 186:	1d 92       	st	X+, r1

00000188 <.do_clear_bss_start>:
 188:	ac 3b       	cpi	r26, 0xBC	; 188
 18a:	b2 07       	cpc	r27, r18
 18c:	e1 f7       	brne	.-8      	; 0x186 <.do_clear_bss_loop>
 18e:	0e 94 c8 04 	call	0x990	; 0x990 <main>
 192:	0c 94 43 06 	jmp	0xc86	; 0xc86 <_exit>

00000196 <__bad_interrupt>:
 196:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000019a <start>:


// 
void start(void)
{
	DDRD|=(1<<_CLK);
 19a:	53 9a       	sbi	0x0a, 3	; 10
	DDRD|=(1<<_DIO);
 19c:	54 9a       	sbi	0x0a, 4	; 10
	PORTD |= (1<<_CLK);
 19e:	5b 9a       	sbi	0x0b, 3	; 11
	PORTD |= (1<<_DIO);
 1a0:	5c 9a       	sbi	0x0b, 4	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1a2:	8d e0       	ldi	r24, 0x0D	; 13
 1a4:	8a 95       	dec	r24
 1a6:	f1 f7       	brne	.-4      	; 0x1a4 <start+0xa>
 1a8:	00 00       	nop
	_delay_us(5);
	PORTD &=~ (1<<_DIO);
 1aa:	5c 98       	cbi	0x0b, 4	; 11
	PORTD &=~ (1<<_CLK);
 1ac:	5b 98       	cbi	0x0b, 3	; 11
 1ae:	8d e0       	ldi	r24, 0x0D	; 13
 1b0:	8a 95       	dec	r24
 1b2:	f1 f7       	brne	.-4      	; 0x1b0 <start+0x16>
 1b4:	00 00       	nop
 1b6:	08 95       	ret

000001b8 <stop>:
}

//
void stop(void)
{
	DDRD|=(1<<_CLK);
 1b8:	53 9a       	sbi	0x0a, 3	; 10
	DDRD|=(1<<_DIO);
 1ba:	54 9a       	sbi	0x0a, 4	; 10
	PORTD &=~ (1<<_CLK);
 1bc:	5b 98       	cbi	0x0b, 3	; 11
	PORTD &=~ (1<<_DIO);
 1be:	5c 98       	cbi	0x0b, 4	; 11
 1c0:	8d e0       	ldi	r24, 0x0D	; 13
 1c2:	8a 95       	dec	r24
 1c4:	f1 f7       	brne	.-4      	; 0x1c2 <stop+0xa>
 1c6:	00 00       	nop
	_delay_us(5);
	PORTD |= (1<<_CLK);
 1c8:	5b 9a       	sbi	0x0b, 3	; 11
	PORTD |= (1<<_DIO);
 1ca:	5c 9a       	sbi	0x0b, 4	; 11
 1cc:	8d e0       	ldi	r24, 0x0D	; 13
 1ce:	8a 95       	dec	r24
 1d0:	f1 f7       	brne	.-4      	; 0x1ce <stop+0x16>
 1d2:	00 00       	nop
 1d4:	08 95       	ret

000001d6 <writeValue>:
	_delay_us(5);
}

//
void writeValue(uint8_t value)
{
 1d6:	20 e0       	ldi	r18, 0x00	; 0
 1d8:	30 e0       	ldi	r19, 0x00	; 0
	for(uint8_t i = 0; i < 8; i++)
	{
		PORTD &=~ (1<<_CLK);
		_delay_us(5);
		if((value & (1 << i)))
 1da:	90 e0       	ldi	r25, 0x00	; 0
//
void writeValue(uint8_t value)
{
	for(uint8_t i = 0; i < 8; i++)
	{
		PORTD &=~ (1<<_CLK);
 1dc:	5b 98       	cbi	0x0b, 3	; 11
 1de:	4d e0       	ldi	r20, 0x0D	; 13
 1e0:	4a 95       	dec	r20
 1e2:	f1 f7       	brne	.-4      	; 0x1e0 <writeValue+0xa>
 1e4:	00 00       	nop
		_delay_us(5);
		if((value & (1 << i)))
 1e6:	ac 01       	movw	r20, r24
 1e8:	02 2e       	mov	r0, r18
 1ea:	02 c0       	rjmp	.+4      	; 0x1f0 <writeValue+0x1a>
 1ec:	55 95       	asr	r21
 1ee:	47 95       	ror	r20
 1f0:	0a 94       	dec	r0
 1f2:	e2 f7       	brpl	.-8      	; 0x1ec <writeValue+0x16>
 1f4:	40 ff       	sbrs	r20, 0
 1f6:	02 c0       	rjmp	.+4      	; 0x1fc <writeValue+0x26>
		PORTD |= (1<<_DIO);
 1f8:	5c 9a       	sbi	0x0b, 4	; 11
 1fa:	01 c0       	rjmp	.+2      	; 0x1fe <writeValue+0x28>
		else
		PORTD &=~ (1<<_DIO);
 1fc:	5c 98       	cbi	0x0b, 4	; 11
 1fe:	4d e0       	ldi	r20, 0x0D	; 13
 200:	4a 95       	dec	r20
 202:	f1 f7       	brne	.-4      	; 0x200 <writeValue+0x2a>
 204:	00 00       	nop
		_delay_us(5);
		PORTD |= (1<<_CLK);
 206:	5b 9a       	sbi	0x0b, 3	; 11
 208:	4d e0       	ldi	r20, 0x0D	; 13
 20a:	4a 95       	dec	r20
 20c:	f1 f7       	brne	.-4      	; 0x20a <writeValue+0x34>
 20e:	00 00       	nop
 210:	2f 5f       	subi	r18, 0xFF	; 255
 212:	3f 4f       	sbci	r19, 0xFF	; 255
}

//
void writeValue(uint8_t value)
{
	for(uint8_t i = 0; i < 8; i++)
 214:	28 30       	cpi	r18, 0x08	; 8
 216:	31 05       	cpc	r19, r1
 218:	09 f7       	brne	.-62     	; 0x1dc <writeValue+0x6>
		PORTD &=~ (1<<_DIO);
		_delay_us(5);
		PORTD |= (1<<_CLK);
		_delay_us(5);
	}
	PORTD &=~ (1<<_CLK);
 21a:	5b 98       	cbi	0x0b, 3	; 11
 21c:	8d e0       	ldi	r24, 0x0D	; 13
 21e:	8a 95       	dec	r24
 220:	f1 f7       	brne	.-4      	; 0x21e <writeValue+0x48>
 222:	00 00       	nop
	_delay_us(5);
	PORTD |= (1<<_CLK);
 224:	5b 9a       	sbi	0x0b, 3	; 11
 226:	4d e0       	ldi	r20, 0x0D	; 13
 228:	4a 95       	dec	r20
 22a:	f1 f7       	brne	.-4      	; 0x228 <writeValue+0x52>
 22c:	00 00       	nop
 22e:	08 95       	ret

00000230 <write>:
}


//
void write(uint8_t n3, uint8_t n2, uint8_t n1, uint8_t n0)
{
 230:	0f 93       	push	r16
 232:	1f 93       	push	r17
 234:	cf 93       	push	r28
 236:	df 93       	push	r29
 238:	08 2f       	mov	r16, r24
 23a:	16 2f       	mov	r17, r22
 23c:	d4 2f       	mov	r29, r20
 23e:	c2 2f       	mov	r28, r18
	start();
 240:	0e 94 cd 00 	call	0x19a	; 0x19a <start>
	writeValue(SetBright); // яркость
 244:	8d e8       	ldi	r24, 0x8D	; 141
 246:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <writeValue>
	start();
 24a:	0e 94 cd 00 	call	0x19a	; 0x19a <start>
	writeValue(0x40); // писать в регистры дисплея
 24e:	80 e4       	ldi	r24, 0x40	; 64
 250:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <writeValue>
	stop();
 254:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <stop>
	start();
 258:	0e 94 cd 00 	call	0x19a	; 0x19a <start>
	writeValue(0xc0); // вывод с 1-го разряда.
 25c:	80 ec       	ldi	r24, 0xC0	; 192
 25e:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <writeValue>
	writeValue(n3);
 262:	80 2f       	mov	r24, r16
 264:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <writeValue>
	writeValue(n2);
 268:	81 2f       	mov	r24, r17
 26a:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <writeValue>
	writeValue(n1);
 26e:	8d 2f       	mov	r24, r29
 270:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <writeValue>
	writeValue(n0);
 274:	8c 2f       	mov	r24, r28
 276:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <writeValue>
	stop();
 27a:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <stop>
}
 27e:	df 91       	pop	r29
 280:	cf 91       	pop	r28
 282:	1f 91       	pop	r17
 284:	0f 91       	pop	r16
 286:	08 95       	ret

00000288 <indication>:



//
void indication(uint16_t n, uint8_t znak)
{
 288:	df 92       	push	r13
 28a:	ef 92       	push	r14
 28c:	ff 92       	push	r15
 28e:	0f 93       	push	r16
 290:	1f 93       	push	r17
 292:	cf 93       	push	r28
 294:	df 93       	push	r29
 296:	ac 01       	movw	r20, r24
 298:	d6 2e       	mov	r13, r22
	uint8_t n1, n2, n3;
	n1 =  n % 10;
 29a:	9c 01       	movw	r18, r24
 29c:	ad ec       	ldi	r26, 0xCD	; 205
 29e:	bc ec       	ldi	r27, 0xCC	; 204
 2a0:	0e 94 29 06 	call	0xc52	; 0xc52 <__umulhisi3>
 2a4:	96 95       	lsr	r25
 2a6:	87 95       	ror	r24
 2a8:	96 95       	lsr	r25
 2aa:	87 95       	ror	r24
 2ac:	96 95       	lsr	r25
 2ae:	87 95       	ror	r24
 2b0:	9c 01       	movw	r18, r24
 2b2:	22 0f       	add	r18, r18
 2b4:	33 1f       	adc	r19, r19
 2b6:	88 0f       	add	r24, r24
 2b8:	99 1f       	adc	r25, r25
 2ba:	88 0f       	add	r24, r24
 2bc:	99 1f       	adc	r25, r25
 2be:	88 0f       	add	r24, r24
 2c0:	99 1f       	adc	r25, r25
 2c2:	82 0f       	add	r24, r18
 2c4:	93 1f       	adc	r25, r19
 2c6:	fa 01       	movw	r30, r20
 2c8:	e8 1b       	sub	r30, r24
 2ca:	f9 0b       	sbc	r31, r25
	n2 = ((n % 100)-n1)/10;
 2cc:	ff 27       	eor	r31, r31
 2ce:	9a 01       	movw	r18, r20
 2d0:	36 95       	lsr	r19
 2d2:	27 95       	ror	r18
 2d4:	36 95       	lsr	r19
 2d6:	27 95       	ror	r18
 2d8:	ab e7       	ldi	r26, 0x7B	; 123
 2da:	b4 e1       	ldi	r27, 0x14	; 20
 2dc:	0e 94 29 06 	call	0xc52	; 0xc52 <__umulhisi3>
 2e0:	96 95       	lsr	r25
 2e2:	87 95       	ror	r24
 2e4:	64 e6       	ldi	r22, 0x64	; 100
 2e6:	68 9f       	mul	r22, r24
 2e8:	90 01       	movw	r18, r0
 2ea:	69 9f       	mul	r22, r25
 2ec:	30 0d       	add	r19, r0
 2ee:	11 24       	eor	r1, r1
 2f0:	ca 01       	movw	r24, r20
 2f2:	82 1b       	sub	r24, r18
 2f4:	93 0b       	sbc	r25, r19
 2f6:	9c 01       	movw	r18, r24
 2f8:	2e 1b       	sub	r18, r30
 2fa:	3f 0b       	sbc	r19, r31
 2fc:	ad ec       	ldi	r26, 0xCD	; 205
 2fe:	bc ec       	ldi	r27, 0xCC	; 204
 300:	0e 94 29 06 	call	0xc52	; 0xc52 <__umulhisi3>
 304:	96 95       	lsr	r25
 306:	87 95       	ror	r24
 308:	96 95       	lsr	r25
 30a:	87 95       	ror	r24
 30c:	96 95       	lsr	r25
 30e:	87 95       	ror	r24
	n3 = ((n % 1000) - n2 - n1) / 100;
 310:	ec 01       	movw	r28, r24
 312:	dd 27       	eor	r29, r29
	write(digits[n3], digits[n2], digits[n1], znak);
 314:	df 01       	movw	r26, r30
 316:	a0 50       	subi	r26, 0x00	; 0
 318:	bf 4f       	sbci	r27, 0xFF	; 255
 31a:	7d 01       	movw	r14, r26
 31c:	8e 01       	movw	r16, r28
 31e:	00 50       	subi	r16, 0x00	; 0
 320:	1f 4f       	sbci	r17, 0xFF	; 255
void indication(uint16_t n, uint8_t znak)
{
	uint8_t n1, n2, n3;
	n1 =  n % 10;
	n2 = ((n % 100)-n1)/10;
	n3 = ((n % 1000) - n2 - n1) / 100;
 322:	9a 01       	movw	r18, r20
 324:	36 95       	lsr	r19
 326:	27 95       	ror	r18
 328:	36 95       	lsr	r19
 32a:	27 95       	ror	r18
 32c:	36 95       	lsr	r19
 32e:	27 95       	ror	r18
 330:	a5 ec       	ldi	r26, 0xC5	; 197
 332:	b0 e2       	ldi	r27, 0x20	; 32
 334:	0e 94 29 06 	call	0xc52	; 0xc52 <__umulhisi3>
 338:	92 95       	swap	r25
 33a:	82 95       	swap	r24
 33c:	8f 70       	andi	r24, 0x0F	; 15
 33e:	89 27       	eor	r24, r25
 340:	9f 70       	andi	r25, 0x0F	; 15
 342:	89 27       	eor	r24, r25
 344:	68 ee       	ldi	r22, 0xE8	; 232
 346:	73 e0       	ldi	r23, 0x03	; 3
 348:	86 9f       	mul	r24, r22
 34a:	90 01       	movw	r18, r0
 34c:	87 9f       	mul	r24, r23
 34e:	30 0d       	add	r19, r0
 350:	96 9f       	mul	r25, r22
 352:	30 0d       	add	r19, r0
 354:	11 24       	eor	r1, r1
 356:	42 1b       	sub	r20, r18
 358:	53 0b       	sbc	r21, r19
 35a:	4c 1b       	sub	r20, r28
 35c:	5d 0b       	sbc	r21, r29
 35e:	4e 1b       	sub	r20, r30
 360:	5f 0b       	sbc	r21, r31
 362:	9a 01       	movw	r18, r20
 364:	36 95       	lsr	r19
 366:	27 95       	ror	r18
 368:	36 95       	lsr	r19
 36a:	27 95       	ror	r18
 36c:	ab e7       	ldi	r26, 0x7B	; 123
 36e:	b4 e1       	ldi	r27, 0x14	; 20
 370:	0e 94 29 06 	call	0xc52	; 0xc52 <__umulhisi3>
 374:	96 95       	lsr	r25
 376:	87 95       	ror	r24
 378:	fc 01       	movw	r30, r24
 37a:	ff 27       	eor	r31, r31
	write(digits[n3], digits[n2], digits[n1], znak);
 37c:	e0 50       	subi	r30, 0x00	; 0
 37e:	ff 4f       	sbci	r31, 0xFF	; 255
 380:	2d 2d       	mov	r18, r13
 382:	d7 01       	movw	r26, r14
 384:	4c 91       	ld	r20, X
 386:	d8 01       	movw	r26, r16
 388:	6c 91       	ld	r22, X
 38a:	80 81       	ld	r24, Z
 38c:	0e 94 18 01 	call	0x230	; 0x230 <write>
}
 390:	df 91       	pop	r29
 392:	cf 91       	pop	r28
 394:	1f 91       	pop	r17
 396:	0f 91       	pop	r16
 398:	ff 90       	pop	r15
 39a:	ef 90       	pop	r14
 39c:	df 90       	pop	r13
 39e:	08 95       	ret

000003a0 <fn_SetMeas>:
*/


void fn_SetMeas(void)
{
	sMeasure.cCounter=0;
 3a0:	10 92 1d 01 	sts	0x011D, r1
	sMeasure.cReady=1;
 3a4:	81 e0       	ldi	r24, 0x01	; 1
 3a6:	80 93 b0 02 	sts	0x02B0, r24
 3aa:	08 95       	ret

000003ac <read_adc>:
}
//------------------------------------------------
// Read the AD conversion result
unsigned int read_adc(unsigned char adc_input)
{
	ADMUX=adc_input | (ADC_VREF_TYPE & 0xff);
 3ac:	80 64       	ori	r24, 0x40	; 64
 3ae:	80 93 7c 00 	sts	0x007C, r24
 3b2:	8a e1       	ldi	r24, 0x1A	; 26
 3b4:	8a 95       	dec	r24
 3b6:	f1 f7       	brne	.-4      	; 0x3b4 <read_adc+0x8>
 3b8:	00 c0       	rjmp	.+0      	; 0x3ba <read_adc+0xe>
	// Delay needed for the stabilization of the ADC input voltage
	_delay_us(10);
	// Start the AD conversion
	ADCSRA|=0x40;
 3ba:	ea e7       	ldi	r30, 0x7A	; 122
 3bc:	f0 e0       	ldi	r31, 0x00	; 0
 3be:	80 81       	ld	r24, Z
 3c0:	80 64       	ori	r24, 0x40	; 64
 3c2:	80 83       	st	Z, r24
	// Wait for the AD conversion to complete
	while ((ADCSRA & 0x10)==0);
 3c4:	80 81       	ld	r24, Z
 3c6:	84 ff       	sbrs	r24, 4
 3c8:	fd cf       	rjmp	.-6      	; 0x3c4 <read_adc+0x18>
	ADCSRA|=0x10;
 3ca:	ea e7       	ldi	r30, 0x7A	; 122
 3cc:	f0 e0       	ldi	r31, 0x00	; 0
 3ce:	80 81       	ld	r24, Z
 3d0:	80 61       	ori	r24, 0x10	; 16
 3d2:	80 83       	st	Z, r24
	return ADCW;
 3d4:	80 91 78 00 	lds	r24, 0x0078
 3d8:	90 91 79 00 	lds	r25, 0x0079
}
 3dc:	08 95       	ret

000003de <__vector_13>:
#include <avr/interrupt.h>
//#include "adc_rms.h"

//-----------------------------------------------
ISR (TIMER1_OVF_vect)
{
 3de:	1f 92       	push	r1
 3e0:	0f 92       	push	r0
 3e2:	0f b6       	in	r0, 0x3f	; 63
 3e4:	0f 92       	push	r0
 3e6:	11 24       	eor	r1, r1
 3e8:	0f 93       	push	r16
 3ea:	1f 93       	push	r17
 3ec:	2f 93       	push	r18
 3ee:	3f 93       	push	r19
 3f0:	4f 93       	push	r20
 3f2:	5f 93       	push	r21
 3f4:	6f 93       	push	r22
 3f6:	7f 93       	push	r23
 3f8:	8f 93       	push	r24
 3fa:	9f 93       	push	r25
 3fc:	af 93       	push	r26
 3fe:	bf 93       	push	r27
 400:	cf 93       	push	r28
 402:	df 93       	push	r29
 404:	ef 93       	push	r30
 406:	ff 93       	push	r31
	//PORTB^=(1<<PB7);
	TCNT1+=TMR1_CALCULATE;
 408:	e4 e8       	ldi	r30, 0x84	; 132
 40a:	f0 e0       	ldi	r31, 0x00	; 0
 40c:	80 81       	ld	r24, Z
 40e:	91 81       	ldd	r25, Z+1	; 0x01
 410:	98 54       	subi	r25, 0x48	; 72
 412:	91 83       	std	Z+1, r25	; 0x01
 414:	80 83       	st	Z, r24
	if(sMeasure.cReady)
 416:	80 91 b0 02 	lds	r24, 0x02B0
 41a:	88 23       	and	r24, r24
 41c:	b1 f0       	breq	.+44     	; 0x44a <__vector_13+0x6c>
	{
		sMeasure.iArr[sMeasure.cCounter]= read_adc(0);
 41e:	cd e1       	ldi	r28, 0x1D	; 29
 420:	d1 e0       	ldi	r29, 0x01	; 1
 422:	08 81       	ld	r16, Y
 424:	10 e0       	ldi	r17, 0x00	; 0
 426:	80 e0       	ldi	r24, 0x00	; 0
 428:	0e 94 d6 01 	call	0x3ac	; 0x3ac <read_adc>
 42c:	f8 01       	movw	r30, r16
 42e:	ee 0f       	add	r30, r30
 430:	ff 1f       	adc	r31, r31
 432:	e3 5e       	subi	r30, 0xE3	; 227
 434:	fe 4f       	sbci	r31, 0xFE	; 254
 436:	92 83       	std	Z+2, r25	; 0x02
 438:	81 83       	std	Z+1, r24	; 0x01
		sMeasure.cCounter++;
 43a:	88 81       	ld	r24, Y
 43c:	8f 5f       	subi	r24, 0xFF	; 255
 43e:	88 83       	st	Y, r24
		if(sMeasure.cCounter >= N_IZM){sMeasure.cReady=0;}
 440:	88 81       	ld	r24, Y
 442:	88 3c       	cpi	r24, 0xC8	; 200
 444:	10 f0       	brcs	.+4      	; 0x44a <__vector_13+0x6c>
 446:	10 92 b0 02 	sts	0x02B0, r1
	}
}
 44a:	ff 91       	pop	r31
 44c:	ef 91       	pop	r30
 44e:	df 91       	pop	r29
 450:	cf 91       	pop	r28
 452:	bf 91       	pop	r27
 454:	af 91       	pop	r26
 456:	9f 91       	pop	r25
 458:	8f 91       	pop	r24
 45a:	7f 91       	pop	r23
 45c:	6f 91       	pop	r22
 45e:	5f 91       	pop	r21
 460:	4f 91       	pop	r20
 462:	3f 91       	pop	r19
 464:	2f 91       	pop	r18
 466:	1f 91       	pop	r17
 468:	0f 91       	pop	r16
 46a:	0f 90       	pop	r0
 46c:	0f be       	out	0x3f, r0	; 63
 46e:	0f 90       	pop	r0
 470:	1f 90       	pop	r1
 472:	18 95       	reti

00000474 <Adc_rms_init>:
void Adc_rms_init()
{
	// ADC initialization
	// ADC Clock frequency: 1000,000 kHz
	// ADC Voltage Reference: AVCC pin
	ADMUX=ADC_VREF_TYPE & 0xff;
 474:	80 e4       	ldi	r24, 0x40	; 64
 476:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA=0x83;
 47a:	83 e8       	ldi	r24, 0x83	; 131
 47c:	80 93 7a 00 	sts	0x007A, r24
 480:	08 95       	ret

00000482 <lsqrt>:
}
unsigned int lsqrt(unsigned  long arg){
 482:	8f 92       	push	r8
 484:	9f 92       	push	r9
 486:	af 92       	push	r10
 488:	bf 92       	push	r11
 48a:	cf 92       	push	r12
 48c:	df 92       	push	r13
 48e:	ef 92       	push	r14
 490:	ff 92       	push	r15
 492:	0f 93       	push	r16
 494:	1f 93       	push	r17
	char count=16;
	unsigned long  res=0,tmp=0;
	if(arg!=0){
 496:	61 15       	cp	r22, r1
 498:	71 05       	cpc	r23, r1
 49a:	81 05       	cpc	r24, r1
 49c:	91 05       	cpc	r25, r1
 49e:	09 f4       	brne	.+2      	; 0x4a2 <lsqrt+0x20>
 4a0:	65 c0       	rjmp	.+202    	; 0x56c <lsqrt+0xea>
		if(!(arg&0xFF000000)){arg<<=8;count-=4;}
 4a2:	8b 01       	movw	r16, r22
 4a4:	9c 01       	movw	r18, r24
 4a6:	00 27       	eor	r16, r16
 4a8:	11 27       	eor	r17, r17
 4aa:	22 27       	eor	r18, r18
 4ac:	01 2b       	or	r16, r17
 4ae:	02 2b       	or	r16, r18
 4b0:	03 2b       	or	r16, r19
 4b2:	09 f0       	breq	.+2      	; 0x4b6 <lsqrt+0x34>
 4b4:	5f c0       	rjmp	.+190    	; 0x574 <lsqrt+0xf2>
 4b6:	98 2f       	mov	r25, r24
 4b8:	87 2f       	mov	r24, r23
 4ba:	76 2f       	mov	r23, r22
 4bc:	66 27       	eor	r22, r22
 4be:	4c e0       	ldi	r20, 0x0C	; 12


		res=1;
		while((tmp<1)&&(count)){
			count--;
 4c0:	41 50       	subi	r20, 0x01	; 1
			if(arg&0x80000000UL)tmp|=2;
 4c2:	8b 01       	movw	r16, r22
 4c4:	9c 01       	movw	r18, r24
 4c6:	00 27       	eor	r16, r16
 4c8:	37 fd       	sbrc	r19, 7
 4ca:	03 95       	inc	r16
 4cc:	11 27       	eor	r17, r17
 4ce:	22 27       	eor	r18, r18
 4d0:	33 27       	eor	r19, r19
 4d2:	00 0f       	add	r16, r16
 4d4:	11 1f       	adc	r17, r17
 4d6:	22 1f       	adc	r18, r18
 4d8:	33 1f       	adc	r19, r19
			if(arg&0x40000000UL)tmp|=1;
 4da:	96 fd       	sbrc	r25, 6
 4dc:	01 60       	ori	r16, 0x01	; 1

			arg<<=2;
 4de:	66 0f       	add	r22, r22
 4e0:	77 1f       	adc	r23, r23
 4e2:	88 1f       	adc	r24, r24
 4e4:	99 1f       	adc	r25, r25
 4e6:	66 0f       	add	r22, r22
 4e8:	77 1f       	adc	r23, r23
 4ea:	88 1f       	adc	r24, r24
 4ec:	99 1f       	adc	r25, r25
	if(arg!=0){
		if(!(arg&0xFF000000)){arg<<=8;count-=4;}


		res=1;
		while((tmp<1)&&(count)){
 4ee:	01 15       	cp	r16, r1
 4f0:	11 05       	cpc	r17, r1
 4f2:	21 05       	cpc	r18, r1
 4f4:	31 05       	cpc	r19, r1
 4f6:	11 f4       	brne	.+4      	; 0x4fc <lsqrt+0x7a>
 4f8:	41 11       	cpse	r20, r1
 4fa:	e2 cf       	rjmp	.-60     	; 0x4c0 <lsqrt+0x3e>

			arg<<=2;


		};//РїРѕРёСЃРє РїРµСЂРІРѕР№ 1-С‹
		tmp--;
 4fc:	01 50       	subi	r16, 0x01	; 1
 4fe:	11 09       	sbc	r17, r1
 500:	21 09       	sbc	r18, r1
 502:	31 09       	sbc	r19, r1
	unsigned long  res=0,tmp=0;
	if(arg!=0){
		if(!(arg&0xFF000000)){arg<<=8;count-=4;}


		res=1;
 504:	c1 2c       	mov	r12, r1
 506:	d1 2c       	mov	r13, r1
 508:	76 01       	movw	r14, r12
 50a:	c3 94       	inc	r12


		};//РїРѕРёСЃРє РїРµСЂРІРѕР№ 1-С‹
		tmp--;
		//for(count;count;count--)
		while(count--)
 50c:	2c c0       	rjmp	.+88     	; 0x566 <lsqrt+0xe4>
		{
			tmp<<=2;
 50e:	00 0f       	add	r16, r16
 510:	11 1f       	adc	r17, r17
 512:	22 1f       	adc	r18, r18
 514:	33 1f       	adc	r19, r19
 516:	00 0f       	add	r16, r16
 518:	11 1f       	adc	r17, r17
 51a:	22 1f       	adc	r18, r18
 51c:	33 1f       	adc	r19, r19
			res<<=1;
 51e:	cc 0c       	add	r12, r12
 520:	dd 1c       	adc	r13, r13
 522:	ee 1c       	adc	r14, r14
 524:	ff 1c       	adc	r15, r15

			if(arg&0x80000000UL)tmp|=2;
 526:	99 23       	and	r25, r25
 528:	0c f4       	brge	.+2      	; 0x52c <lsqrt+0xaa>
 52a:	02 60       	ori	r16, 0x02	; 2
			if(arg&0x40000000UL)tmp|=1;
 52c:	96 fd       	sbrc	r25, 6
 52e:	01 60       	ori	r16, 0x01	; 1
			arg<<=2;
 530:	66 0f       	add	r22, r22
 532:	77 1f       	adc	r23, r23
 534:	88 1f       	adc	r24, r24
 536:	99 1f       	adc	r25, r25
 538:	66 0f       	add	r22, r22
 53a:	77 1f       	adc	r23, r23
 53c:	88 1f       	adc	r24, r24
 53e:	99 1f       	adc	r25, r25

			if( tmp>=((res<<1)|1)){
 540:	46 01       	movw	r8, r12
 542:	57 01       	movw	r10, r14
 544:	88 0c       	add	r8, r8
 546:	99 1c       	adc	r9, r9
 548:	aa 1c       	adc	r10, r10
 54a:	bb 1c       	adc	r11, r11
 54c:	68 94       	set
 54e:	80 f8       	bld	r8, 0
 550:	08 15       	cp	r16, r8
 552:	19 05       	cpc	r17, r9
 554:	2a 05       	cpc	r18, r10
 556:	3b 05       	cpc	r19, r11
 558:	30 f0       	brcs	.+12     	; 0x566 <lsqrt+0xe4>
				tmp-=((res<<1)|1);
 55a:	08 19       	sub	r16, r8
 55c:	19 09       	sbc	r17, r9
 55e:	2a 09       	sbc	r18, r10
 560:	3b 09       	sbc	r19, r11
				res|=1;
 562:	68 94       	set
 564:	c0 f8       	bld	r12, 0


		};//РїРѕРёСЃРє РїРµСЂРІРѕР№ 1-С‹
		tmp--;
		//for(count;count;count--)
		while(count--)
 566:	41 50       	subi	r20, 0x01	; 1
 568:	90 f6       	brcc	.-92     	; 0x50e <lsqrt+0x8c>
 56a:	06 c0       	rjmp	.+12     	; 0x578 <lsqrt+0xf6>
	ADMUX=ADC_VREF_TYPE & 0xff;
	ADCSRA=0x83;
}
unsigned int lsqrt(unsigned  long arg){
	char count=16;
	unsigned long  res=0,tmp=0;
 56c:	c1 2c       	mov	r12, r1
 56e:	d1 2c       	mov	r13, r1
 570:	76 01       	movw	r14, r12
 572:	02 c0       	rjmp	.+4      	; 0x578 <lsqrt+0xf6>
	// ADC Voltage Reference: AVCC pin
	ADMUX=ADC_VREF_TYPE & 0xff;
	ADCSRA=0x83;
}
unsigned int lsqrt(unsigned  long arg){
	char count=16;
 574:	40 e1       	ldi	r20, 0x10	; 16
 576:	a4 cf       	rjmp	.-184    	; 0x4c0 <lsqrt+0x3e>
			}
			
		}
	}
	return (unsigned int)res;
}
 578:	c6 01       	movw	r24, r12
 57a:	1f 91       	pop	r17
 57c:	0f 91       	pop	r16
 57e:	ff 90       	pop	r15
 580:	ef 90       	pop	r14
 582:	df 90       	pop	r13
 584:	cf 90       	pop	r12
 586:	bf 90       	pop	r11
 588:	af 90       	pop	r10
 58a:	9f 90       	pop	r9
 58c:	8f 90       	pop	r8
 58e:	08 95       	ret

00000590 <fn_Calculate>:
	ADCSRA|=0x10;
	return ADCW;
}
//---------------------------------------d---------
unsigned int fn_Calculate(void)
{
 590:	cf 92       	push	r12
 592:	df 92       	push	r13
 594:	ef 92       	push	r14
 596:	ff 92       	push	r15
 598:	40 e0       	ldi	r20, 0x00	; 0
 59a:	50 e0       	ldi	r21, 0x00	; 0
	unsigned long lRez=0;
 59c:	c1 2c       	mov	r12, r1
 59e:	d1 2c       	mov	r13, r1
 5a0:	76 01       	movw	r14, r12
	unsigned long lKv;
	unsigned char i;
	for(i=0;i<N_IZM;i++)
	{
		lKv=(unsigned long)sMeasure.iArr[i]*(unsigned long)sMeasure.iArr[i];
 5a2:	fa 01       	movw	r30, r20
 5a4:	ee 0f       	add	r30, r30
 5a6:	ff 1f       	adc	r31, r31
 5a8:	e3 5e       	subi	r30, 0xE3	; 227
 5aa:	fe 4f       	sbci	r31, 0xFE	; 254
 5ac:	a1 81       	ldd	r26, Z+1	; 0x01
 5ae:	b2 81       	ldd	r27, Z+2	; 0x02
 5b0:	21 81       	ldd	r18, Z+1	; 0x01
 5b2:	32 81       	ldd	r19, Z+2	; 0x02
 5b4:	0e 94 29 06 	call	0xc52	; 0xc52 <__umulhisi3>
		lRez+=lKv;
 5b8:	c6 0e       	add	r12, r22
 5ba:	d7 1e       	adc	r13, r23
 5bc:	e8 1e       	adc	r14, r24
 5be:	f9 1e       	adc	r15, r25
 5c0:	4f 5f       	subi	r20, 0xFF	; 255
 5c2:	5f 4f       	sbci	r21, 0xFF	; 255
unsigned int fn_Calculate(void)
{
	unsigned long lRez=0;
	unsigned long lKv;
	unsigned char i;
	for(i=0;i<N_IZM;i++)
 5c4:	48 3c       	cpi	r20, 0xC8	; 200
 5c6:	51 05       	cpc	r21, r1
 5c8:	61 f7       	brne	.-40     	; 0x5a2 <fn_Calculate+0x12>
	{
		lKv=(unsigned long)sMeasure.iArr[i]*(unsigned long)sMeasure.iArr[i];
		lRez+=lKv;
	}
	lRez/=N_IZM;
 5ca:	c7 01       	movw	r24, r14
 5cc:	b6 01       	movw	r22, r12
 5ce:	28 ec       	ldi	r18, 0xC8	; 200
 5d0:	30 e0       	ldi	r19, 0x00	; 0
 5d2:	40 e0       	ldi	r20, 0x00	; 0
 5d4:	50 e0       	ldi	r21, 0x00	; 0
 5d6:	0e 94 01 06 	call	0xc02	; 0xc02 <__udivmodsi4>
	//return sqrt_ll(lRez);
	return lsqrt(lRez);
 5da:	ca 01       	movw	r24, r20
 5dc:	b9 01       	movw	r22, r18
 5de:	0e 94 41 02 	call	0x482	; 0x482 <lsqrt>
}
 5e2:	ff 90       	pop	r15
 5e4:	ef 90       	pop	r14
 5e6:	df 90       	pop	r13
 5e8:	cf 90       	pop	r12
 5ea:	08 95       	ret

000005ec <BtnInit>:
  
//----------------------------------------------------------------------------------------------------------------------- 
//функция инициализации портов (вызвать перед использованием библиотеки) 
void BtnInit (void)                              
{    
    BTN_PORT |= ( BTN_LINE2 | BTN_LINE4);//подтяжка кнопок 
 5ec:	8b b1       	in	r24, 0x0b	; 11
 5ee:	8a 60       	ori	r24, 0x0A	; 10
 5f0:	8b b9       	out	0x0b, r24	; 11
 5f2:	08 95       	ret

000005f4 <BtnGet>:
//----------------------------------------------------------------------------------------------------------------------- 
//функция чтения маски нажатых кнопок  
//возвращает маску нажатых кнопок (биты 0-3 - коротк нажат, биты 4-7 - длинн нажат) 
uint8_t BtnGet (void)                               
{    
	asm ("cli");
 5f4:	f8 94       	cli
    uint8_t temp = BtnFlags; 
 5f6:	80 91 b1 02 	lds	r24, 0x02B1
    BtnFlags = 0; 
 5fa:	10 92 b1 02 	sts	0x02B1, r1
	asm ("sei");
 5fe:	78 94       	sei
    return temp; 
} 
 600:	08 95       	ret

00000602 <BtnExe>:
	static uint8_t BtnLongCoun;                 //счетчик длинного нажатия 
	static uint8_t BtnMascLast;                 //запомнить маску нажатой кнопки для анализа после отжатия кнопки 

	uint8_t BtnMask = 0;  
	//if (~BTN_PIN & BTN_LINE1) 	BtnMask = BTN_SHRT1;//формирование маски нажатых кнопок 
	if (~BTN_PIN & BTN_LINE2) 	BtnMask = BTN_SHRT2;
 602:	49 99       	sbic	0x09, 1	; 9
 604:	43 c0       	rjmp	.+134    	; 0x68c <BtnExe+0x8a>
	//if (~BTN_PIN & BTN_LINE3) 	BtnMask = BTN_SHRT3;
	if (~BTN_PIN & BTN_LINE4) 	BtnMask = BTN_SHRT4;
 606:	4b 9b       	sbis	0x09, 3	; 9
 608:	02 c0       	rjmp	.+4      	; 0x60e <BtnExe+0xc>
	static uint8_t BtnLongCoun;                 //счетчик длинного нажатия 
	static uint8_t BtnMascLast;                 //запомнить маску нажатой кнопки для анализа после отжатия кнопки 

	uint8_t BtnMask = 0;  
	//if (~BTN_PIN & BTN_LINE1) 	BtnMask = BTN_SHRT1;//формирование маски нажатых кнопок 
	if (~BTN_PIN & BTN_LINE2) 	BtnMask = BTN_SHRT2;
 60a:	92 e0       	ldi	r25, 0x02	; 2
 60c:	03 c0       	rjmp	.+6      	; 0x614 <BtnExe+0x12>
	//if (~BTN_PIN & BTN_LINE3) 	BtnMask = BTN_SHRT3;
	if (~BTN_PIN & BTN_LINE4) 	BtnMask = BTN_SHRT4;
 60e:	98 e0       	ldi	r25, 0x08	; 8
 610:	01 c0       	rjmp	.+2      	; 0x614 <BtnExe+0x12>
 612:	98 e0       	ldi	r25, 0x08	; 8

	//основной алгоритм обработки событий кнопки 
	if (BtnMask){                               //клавиша нажата 
		BtnMascLast = BtnMask;                  //запоминаем для использования после отпускания кнопки 
 614:	90 93 0f 01 	sts	0x010F, r25

		if (BtnLockCoun < (BTN_LOCK_TIME/10)){ 
 618:	80 91 0e 01 	lds	r24, 0x010E
 61c:	82 30       	cpi	r24, 0x02	; 2
 61e:	20 f4       	brcc	.+8      	; 0x628 <BtnExe+0x26>
			BtnLockCoun++;                      //обработка дребезга 
 620:	8f 5f       	subi	r24, 0xFF	; 255
 622:	80 93 0e 01 	sts	0x010E, r24
			return; 
 626:	08 95       	ret
		} 

		BtnLockBit=1;                           //нажатие зафиксировано      
 628:	81 e0       	ldi	r24, 0x01	; 1
 62a:	80 93 0d 01 	sts	0x010D, r24
		if (BtnLongCoun >= (BTN_LONG_TIME/10))                                
 62e:	80 91 0c 01 	lds	r24, 0x010C
 632:	8e 31       	cpi	r24, 0x1E	; 30
 634:	70 f5       	brcc	.+92     	; 0x692 <BtnExe+0x90>
			return; 
		
		if (++BtnLongCoun >= (BTN_LONG_TIME/10)) 
 636:	8f 5f       	subi	r24, 0xFF	; 255
 638:	80 93 0c 01 	sts	0x010C, r24
 63c:	8e 31       	cpi	r24, 0x1E	; 30
 63e:	48 f1       	brcs	.+82     	; 0x692 <BtnExe+0x90>
			BtnFlags |= (BtnMask << 4);         //установка бита длинного нажатия (старшие 4 бита флагов ButtonByte) 
 640:	20 91 b1 02 	lds	r18, 0x02B1
 644:	30 e1       	ldi	r19, 0x10	; 16
 646:	93 9f       	mul	r25, r19
 648:	c0 01       	movw	r24, r0
 64a:	11 24       	eor	r1, r1
 64c:	82 2b       	or	r24, r18
 64e:	80 93 b1 02 	sts	0x02B1, r24
 652:	08 95       	ret
	} 

	else{                                       //клавиша отжата             
		if (BtnLockCoun){                       //обработка дребезга 
 654:	80 91 0e 01 	lds	r24, 0x010E
 658:	88 23       	and	r24, r24
 65a:	21 f0       	breq	.+8      	; 0x664 <BtnExe+0x62>
			BtnLockCoun --; 
 65c:	81 50       	subi	r24, 0x01	; 1
 65e:	80 93 0e 01 	sts	0x010E, r24
			return; 
 662:	08 95       	ret
		} 

		if (! BtnLockBit)                     	//отжатие зафиксировано 
 664:	80 91 0d 01 	lds	r24, 0x010D
 668:	88 23       	and	r24, r24
 66a:	99 f0       	breq	.+38     	; 0x692 <BtnExe+0x90>
			return; 

		BtnLockBit =0; 
 66c:	10 92 0d 01 	sts	0x010D, r1
		if (BtnLongCoun < (BTN_LONG_TIME/10)) 
 670:	80 91 0c 01 	lds	r24, 0x010C
 674:	8e 31       	cpi	r24, 0x1E	; 30
 676:	38 f4       	brcc	.+14     	; 0x686 <BtnExe+0x84>
			BtnFlags |= BtnMascLast;            //установка бита короткого нажатия (младшие 4 бита флагов ButtonByte) 
 678:	90 91 b1 02 	lds	r25, 0x02B1
 67c:	80 91 0f 01 	lds	r24, 0x010F
 680:	89 2b       	or	r24, r25
 682:	80 93 b1 02 	sts	0x02B1, r24
		
		BtnLongCoun = 0; 
 686:	10 92 0c 01 	sts	0x010C, r1
 68a:	08 95       	ret

	uint8_t BtnMask = 0;  
	//if (~BTN_PIN & BTN_LINE1) 	BtnMask = BTN_SHRT1;//формирование маски нажатых кнопок 
	if (~BTN_PIN & BTN_LINE2) 	BtnMask = BTN_SHRT2;
	//if (~BTN_PIN & BTN_LINE3) 	BtnMask = BTN_SHRT3;
	if (~BTN_PIN & BTN_LINE4) 	BtnMask = BTN_SHRT4;
 68c:	4b 9b       	sbis	0x09, 3	; 9
 68e:	c1 cf       	rjmp	.-126    	; 0x612 <BtnExe+0x10>
 690:	e1 cf       	rjmp	.-62     	; 0x654 <BtnExe+0x52>
 692:	08 95       	ret

00000694 <calculate_segments>:

uint8_t calculate_segments(uint8_t character)
{
	uint8_t segments = 0;

	switch (character)
 694:	90 e0       	ldi	r25, 0x00	; 0
 696:	8a 37       	cpi	r24, 0x7A	; 122
 698:	91 05       	cpc	r25, r1
 69a:	08 f0       	brcs	.+2      	; 0x69e <calculate_segments+0xa>
 69c:	51 c0       	rjmp	.+162    	; 0x740 <calculate_segments+0xac>
 69e:	fc 01       	movw	r30, r24
 6a0:	ec 5c       	subi	r30, 0xCC	; 204
 6a2:	ff 4f       	sbci	r31, 0xFF	; 255
 6a4:	0c 94 23 06 	jmp	0xc46	; 0xc46 <__tablejump2__>
	{
		case 0:
		case '0':
		case 'O':
		segments = (1<<A)|(1<<B)|(1<<C)|(1<<D)|(1<<E)|(1<<F);
 6a8:	8f e3       	ldi	r24, 0x3F	; 63
 6aa:	08 95       	ret
		case 'l':
		segments = (1<<B)|(1<<C);
		break;
		case 2:
		case '2':
		segments = (1<<A)|(1<<B)|(1<<D)|(1<<E)|(1<<G);
 6ac:	8b e5       	ldi	r24, 0x5B	; 91
		break;
 6ae:	08 95       	ret
		case 3:
		case '3':
		segments = (1<<A)|(1<<B)|(1<<C)|(1<<D)|(1<<G);
 6b0:	8f e4       	ldi	r24, 0x4F	; 79
		break;
 6b2:	08 95       	ret
		case 4:
		case '4':
		segments = (1<<B)|(1<<C)|(1<<F)|(1<<G);
 6b4:	86 e6       	ldi	r24, 0x66	; 102
		break;
 6b6:	08 95       	ret
		case 5:
		case '5':
		case 'S':
		case 's':
		segments = (1<<A)|(1<<C)|(1<<D)|(1<<F)|(1<<G);
 6b8:	8d e6       	ldi	r24, 0x6D	; 109
		break;
 6ba:	08 95       	ret
		case 6:
		case '6':
		segments = (1<<A)|(1<<C)|(1<<D)|(1<<E)|(1<<F)|(1<<G);
 6bc:	8d e7       	ldi	r24, 0x7D	; 125
		break;
 6be:	08 95       	ret
		case 7:
		case '7':
		segments = (1<<A)|(1<<B)|(1<<C);
 6c0:	87 e0       	ldi	r24, 0x07	; 7
		break;
 6c2:	08 95       	ret
		case 8:
		case '8':
		segments = (1<<A)|(1<<B)|(1<<C)|(1<<D)|(1<<E)|(1<<F)|(1<<G);
 6c4:	8f e7       	ldi	r24, 0x7F	; 127
		break;
 6c6:	08 95       	ret
		case 9:
		case '9':
		case 'g':
		segments = (1<<A)|(1<<B)|(1<<C)|(1<<D)|(1<<F)|(1<<G);
 6c8:	8f e6       	ldi	r24, 0x6F	; 111
		break;
 6ca:	08 95       	ret
		case 10:
		case 'A':
		case 'a':
		segments = (1<<A)|(1<<B)|(1<<C)|(1<<E)|(1<<F)|(1<<G);
 6cc:	87 e7       	ldi	r24, 0x77	; 119
		break;
 6ce:	08 95       	ret
		case 11:
		case 'B':
		case 'b':
		segments = (1<<C)|(1<<D)|(1<<E)|(1<<F)|(1<<G);
 6d0:	8c e7       	ldi	r24, 0x7C	; 124
		break;
 6d2:	08 95       	ret
		case 12:
		case 'C':
		segments = (1<<A)|(1<<D)|(1<<E)|(1<<F);
 6d4:	89 e3       	ldi	r24, 0x39	; 57
		break;
 6d6:	08 95       	ret
		case 'c':
		segments = (1<<D)|(1<<E)|(1<<G);
 6d8:	88 e5       	ldi	r24, 0x58	; 88
		break;
 6da:	08 95       	ret
		case 13:
		case 'D':
		case 'd':
		segments = (1<<B)|(1<<C)|(1<<D)|(1<<E)|(1<<G);
 6dc:	8e e5       	ldi	r24, 0x5E	; 94
		break;
 6de:	08 95       	ret
		case 14:
		case 'E':
		segments = (1<<A)|(1<<D)|(1<<E)|(1<<F)|(1<<G);
 6e0:	89 e7       	ldi	r24, 0x79	; 121
		break;
 6e2:	08 95       	ret
		case 'e':
		segments = (1<<A)|(1<<B)|(1<<D)|(1<<E)|(1<<F)|(1<<G);
 6e4:	8b e7       	ldi	r24, 0x7B	; 123
		break;
 6e6:	08 95       	ret
		case 15:
		case 'F':
		case 'f':
		segments = (1<<A)|(1<<E)|(1<<F)|(1<<G);
 6e8:	81 e7       	ldi	r24, 0x71	; 113
		break;
 6ea:	08 95       	ret
		case 'G':
		segments = (1<<A)|(1<<C)|(1<<D)|(1<<E)|(1<<F);
 6ec:	8d e3       	ldi	r24, 0x3D	; 61
		break;
 6ee:	08 95       	ret
		case 'H':
		segments = (1<<B)|(1<<C)|(1<<E)|(1<<F)|(1<<G);
 6f0:	86 e7       	ldi	r24, 0x76	; 118
		break;
 6f2:	08 95       	ret
		case 'h':
		segments = (1<<C)|(1<<E)|(1<<F)|(1<<G);
 6f4:	84 e7       	ldi	r24, 0x74	; 116
		break;
 6f6:	08 95       	ret
		case 'i':
		segments = (1<<B)|(1<<C);
		break;
		case 'J':
		case 'j':
		segments = (1<<B)|(1<<C)|(1<<D)|(1<<E);
 6f8:	8e e1       	ldi	r24, 0x1E	; 30
		break;
 6fa:	08 95       	ret
		case 'L':
		segments = (1<<D)|(1<<E)|(1<<F);
 6fc:	88 e3       	ldi	r24, 0x38	; 56
		break;
 6fe:	08 95       	ret
		case 'M':
		case 'm':
		segments = (1<<A)|(1<<C)|(1<<E)|(1<<G);
 700:	85 e5       	ldi	r24, 0x55	; 85
		break;
 702:	08 95       	ret
		case 'N':
		case 'n':
		segments = (1<<C)|(1<<E)|(1<<G);
 704:	84 e5       	ldi	r24, 0x54	; 84
		break;
 706:	08 95       	ret
		case 'o':
		segments = (1<<C)|(1<<D)|(1<<E)|(1<<G);
 708:	8c e5       	ldi	r24, 0x5C	; 92
		break;
 70a:	08 95       	ret
		case 'P':
		case 'p':
		segments = (1<<A)|(1<<B)|(1<<E)|(1<<F)|(1<<G);
 70c:	83 e7       	ldi	r24, 0x73	; 115
		break;
 70e:	08 95       	ret
		case 'Q':
		case 'q':
		segments = (1<<A)|(1<<B)|(1<<C)|(1<<F)|(1<<G);
 710:	87 e6       	ldi	r24, 0x67	; 103
		break;
 712:	08 95       	ret
		case 'R':
		case 'r':
		segments = (1<<E)|(1<<G);
 714:	80 e5       	ldi	r24, 0x50	; 80
		break;
 716:	08 95       	ret
		case 'T':
		case 't':
		segments = (1<<D)|(1<<E)|(1<<F)|(1<<G);
 718:	88 e7       	ldi	r24, 0x78	; 120
		break;
 71a:	08 95       	ret
		case 'U':
		segments = (1<<B)|(1<<C)|(1<<D)|(1<<E)|(1<<F);
 71c:	8e e3       	ldi	r24, 0x3E	; 62
		break;
 71e:	08 95       	ret
		case 'u':
		segments = (1<<C)|(1<<D)|(1<<E);
 720:	8c e1       	ldi	r24, 0x1C	; 28
		break;
 722:	08 95       	ret
		case 'V':
		case 'v':
		segments = (1<<C)|(1<<D)|(1<<E);
 724:	8c e1       	ldi	r24, 0x1C	; 28
		break;
 726:	08 95       	ret
		case 'W':
		case 'w':
		segments = (1<<A)|(1<<C)|(1<<D)|(1<<E);
 728:	8d e1       	ldi	r24, 0x1D	; 29
		break;
 72a:	08 95       	ret
		case 'Y':
		case 'y':
		segments = (1<<B)|(1<<C)|(1<<D)|(1<<F)|(1<<G);
 72c:	8e e6       	ldi	r24, 0x6E	; 110
		break;
 72e:	08 95       	ret
		case '-':
		segments = (1<<G);
 730:	80 e4       	ldi	r24, 0x40	; 64
		break;
 732:	08 95       	ret
		case '"':
		segments = (1<<B)|(1<<F);
 734:	82 e2       	ldi	r24, 0x22	; 34
		break;
 736:	08 95       	ret
		case 0x27:	// "'"
		segments = (1<<B);
 738:	82 e0       	ldi	r24, 0x02	; 2
		break;
 73a:	08 95       	ret
		case '_':
		segments = (1<<D);
 73c:	88 e0       	ldi	r24, 0x08	; 8
		break;
 73e:	08 95       	ret
		case ' ':
		default:
		segments = 0;
 740:	80 e0       	ldi	r24, 0x00	; 0
		break;
 742:	08 95       	ret
		segments = (1<<A)|(1<<B)|(1<<C)|(1<<D)|(1<<E)|(1<<F);
		break;
		case 1:
		case '1':
		case 'l':
		segments = (1<<B)|(1<<C);
 744:	86 e0       	ldi	r24, 0x06	; 6
		segments = 0;
		break;
	}

	return segments;
}
 746:	08 95       	ret

00000748 <clearDisplay>:
}

void clearDisplay(void)
{
	// all digits low
	CLEAR_DIGIT(DIGIT1_PORT, DIGIT1_BIT);
 748:	41 98       	cbi	0x08, 1	; 8
	CLEAR_DIGIT(DIGIT2_PORT, DIGIT2_BIT);
 74a:	42 98       	cbi	0x08, 2	; 8
	CLEAR_DIGIT(DIGIT3_PORT, DIGIT3_BIT);
 74c:	43 98       	cbi	0x08, 3	; 8
	CLEAR_DIGIT(DIGIT4_PORT, DIGIT4_BIT);
 74e:	44 98       	cbi	0x08, 4	; 8
	
	// all segments high
	CLEAR_SEGMENT(A_PORT,  A_BIT);
 750:	28 9a       	sbi	0x05, 0	; 5
	CLEAR_SEGMENT(B_PORT,  B_BIT);
 752:	29 9a       	sbi	0x05, 1	; 5
	CLEAR_SEGMENT(C_PORT,  C_BIT);
 754:	2a 9a       	sbi	0x05, 2	; 5
	CLEAR_SEGMENT(D_PORT,  D_BIT);
 756:	2b 9a       	sbi	0x05, 3	; 5
	CLEAR_SEGMENT(E_PORT,  E_BIT);
 758:	2c 9a       	sbi	0x05, 4	; 5
	CLEAR_SEGMENT(F_PORT,  F_BIT);
 75a:	2d 9a       	sbi	0x05, 5	; 5
	CLEAR_SEGMENT(G_PORT,  G_BIT);
 75c:	2e 9a       	sbi	0x05, 6	; 5
	CLEAR_SEGMENT(DP_PORT, DP_BIT);
 75e:	2f 9a       	sbi	0x05, 7	; 5
 760:	08 95       	ret

00000762 <display>:
	return segments;
}

// Output number to digit 0, 1, 2 or 3
void display(uint8_t pos, uint8_t digit)
{
 762:	cf 93       	push	r28
 764:	df 93       	push	r29
 766:	d8 2f       	mov	r29, r24
 768:	c6 2f       	mov	r28, r22
	clearDisplay();
 76a:	0e 94 a4 03 	call	0x748	; 0x748 <clearDisplay>

	//  Turn on selected digit
	switch (digit)
 76e:	c2 30       	cpi	r28, 0x02	; 2
 770:	59 f0       	breq	.+22     	; 0x788 <display+0x26>
 772:	18 f4       	brcc	.+6      	; 0x77a <display+0x18>
 774:	c1 30       	cpi	r28, 0x01	; 1
 776:	31 f0       	breq	.+12     	; 0x784 <display+0x22>
 778:	0c c0       	rjmp	.+24     	; 0x792 <display+0x30>
 77a:	c3 30       	cpi	r28, 0x03	; 3
 77c:	39 f0       	breq	.+14     	; 0x78c <display+0x2a>
 77e:	c4 30       	cpi	r28, 0x04	; 4
 780:	39 f0       	breq	.+14     	; 0x790 <display+0x2e>
 782:	07 c0       	rjmp	.+14     	; 0x792 <display+0x30>
	{
		case 1:
		SET_DIGIT(DIGIT1_PORT, DIGIT1_BIT);
 784:	41 9a       	sbi	0x08, 1	; 8
		break;
 786:	05 c0       	rjmp	.+10     	; 0x792 <display+0x30>
		case 2:
		SET_DIGIT(DIGIT2_PORT, DIGIT2_BIT);
 788:	42 9a       	sbi	0x08, 2	; 8
		break;
 78a:	03 c0       	rjmp	.+6      	; 0x792 <display+0x30>
		case 3:
		SET_DIGIT(DIGIT3_PORT, DIGIT3_BIT);
 78c:	43 9a       	sbi	0x08, 3	; 8
		break;
 78e:	01 c0       	rjmp	.+2      	; 0x792 <display+0x30>
		case 4:
		SET_DIGIT(DIGIT4_PORT, DIGIT4_BIT);
 790:	44 9a       	sbi	0x08, 4	; 8
		break;
	}

	uint8_t segments = 0;

	if (data[pos] & 0b10000000)
 792:	2d 2f       	mov	r18, r29
 794:	30 e0       	ldi	r19, 0x00	; 0
 796:	f9 01       	movw	r30, r18
 798:	ee 54       	subi	r30, 0x4E	; 78
 79a:	fd 4f       	sbci	r31, 0xFD	; 253
 79c:	80 81       	ld	r24, Z
 79e:	88 23       	and	r24, r24
 7a0:	2c f4       	brge	.+10     	; 0x7ac <display+0x4a>
	segments = segment_data[pos];
 7a2:	f9 01       	movw	r30, r18
 7a4:	ea 54       	subi	r30, 0x4A	; 74
 7a6:	fd 4f       	sbci	r31, 0xFD	; 253
 7a8:	80 81       	ld	r24, Z
 7aa:	02 c0       	rjmp	.+4      	; 0x7b0 <display+0x4e>
	else
	segments = calculate_segments(data[pos]);
 7ac:	0e 94 4a 03 	call	0x694	; 0x694 <calculate_segments>
	
	// set dot
	if (dots & (1<<digit))
 7b0:	20 91 11 01 	lds	r18, 0x0111
 7b4:	30 e0       	ldi	r19, 0x00	; 0
 7b6:	b9 01       	movw	r22, r18
 7b8:	02 c0       	rjmp	.+4      	; 0x7be <display+0x5c>
 7ba:	75 95       	asr	r23
 7bc:	67 95       	ror	r22
 7be:	ca 95       	dec	r28
 7c0:	e2 f7       	brpl	.-8      	; 0x7ba <display+0x58>
 7c2:	60 fd       	sbrc	r22, 0
	segments |= (1<<DP);
 7c4:	80 68       	ori	r24, 0x80	; 128

	// This allows segments do be on different ports
	if (segments & _BV(7)) SET_SEGMENT(DP_PORT, DP_BIT);
 7c6:	88 23       	and	r24, r24
 7c8:	14 f4       	brge	.+4      	; 0x7ce <display+0x6c>
 7ca:	2f 98       	cbi	0x05, 7	; 5
 7cc:	01 c0       	rjmp	.+2      	; 0x7d0 <display+0x6e>
	else CLEAR_SEGMENT(DP_PORT, DP_BIT);
 7ce:	2f 9a       	sbi	0x05, 7	; 5

	if (segments & _BV(6)) SET_SEGMENT(G_PORT, G_BIT);
 7d0:	86 ff       	sbrs	r24, 6
 7d2:	02 c0       	rjmp	.+4      	; 0x7d8 <display+0x76>
 7d4:	2e 98       	cbi	0x05, 6	; 5
 7d6:	01 c0       	rjmp	.+2      	; 0x7da <display+0x78>
	else CLEAR_SEGMENT(G_PORT, G_BIT);
 7d8:	2e 9a       	sbi	0x05, 6	; 5

	if (segments & _BV(5)) SET_SEGMENT(F_PORT, F_BIT);
 7da:	85 ff       	sbrs	r24, 5
 7dc:	02 c0       	rjmp	.+4      	; 0x7e2 <display+0x80>
 7de:	2d 98       	cbi	0x05, 5	; 5
 7e0:	01 c0       	rjmp	.+2      	; 0x7e4 <display+0x82>
	else CLEAR_SEGMENT(F_PORT, F_BIT);
 7e2:	2d 9a       	sbi	0x05, 5	; 5

	if (segments & _BV(4)) SET_SEGMENT(E_PORT, E_BIT);
 7e4:	84 ff       	sbrs	r24, 4
 7e6:	02 c0       	rjmp	.+4      	; 0x7ec <display+0x8a>
 7e8:	2c 98       	cbi	0x05, 4	; 5
 7ea:	01 c0       	rjmp	.+2      	; 0x7ee <display+0x8c>
	else CLEAR_SEGMENT(E_PORT, E_BIT);
 7ec:	2c 9a       	sbi	0x05, 4	; 5

	if (segments & _BV(3)) SET_SEGMENT(D_PORT, D_BIT);
 7ee:	83 ff       	sbrs	r24, 3
 7f0:	02 c0       	rjmp	.+4      	; 0x7f6 <display+0x94>
 7f2:	2b 98       	cbi	0x05, 3	; 5
 7f4:	01 c0       	rjmp	.+2      	; 0x7f8 <display+0x96>
	else CLEAR_SEGMENT(D_PORT, D_BIT);
 7f6:	2b 9a       	sbi	0x05, 3	; 5

	if (segments & _BV(2)) SET_SEGMENT(C_PORT, C_BIT);
 7f8:	82 ff       	sbrs	r24, 2
 7fa:	02 c0       	rjmp	.+4      	; 0x800 <display+0x9e>
 7fc:	2a 98       	cbi	0x05, 2	; 5
 7fe:	01 c0       	rjmp	.+2      	; 0x802 <display+0xa0>
	else CLEAR_SEGMENT(C_PORT, C_BIT);
 800:	2a 9a       	sbi	0x05, 2	; 5
	
	if (segments & _BV(1)) SET_SEGMENT(B_PORT, B_BIT);
 802:	81 ff       	sbrs	r24, 1
 804:	02 c0       	rjmp	.+4      	; 0x80a <display+0xa8>
 806:	29 98       	cbi	0x05, 1	; 5
 808:	01 c0       	rjmp	.+2      	; 0x80c <display+0xaa>
	else CLEAR_SEGMENT(B_PORT, B_BIT);
 80a:	29 9a       	sbi	0x05, 1	; 5

	if (segments & _BV(0)) SET_SEGMENT(A_PORT, A_BIT);
 80c:	80 ff       	sbrs	r24, 0
 80e:	02 c0       	rjmp	.+4      	; 0x814 <display+0xb2>
 810:	28 98       	cbi	0x05, 0	; 5
 812:	01 c0       	rjmp	.+2      	; 0x816 <display+0xb4>
	else CLEAR_SEGMENT(A_PORT, A_BIT);
 814:	28 9a       	sbi	0x05, 0	; 5
}
 816:	df 91       	pop	r29
 818:	cf 91       	pop	r28
 81a:	08 95       	ret

0000081c <display_multiplex>:
uint8_t multiplex_counter = 0;

// display multiplexing routine: run once every 5us
void display_multiplex(void)
{
	if (multiplex_counter == 0)
 81c:	80 91 10 01 	lds	r24, 0x0110
 820:	81 11       	cpse	r24, r1
 822:	04 c0       	rjmp	.+8      	; 0x82c <display_multiplex+0x10>
	display(0, 1);
 824:	61 e0       	ldi	r22, 0x01	; 1
 826:	0e 94 b1 03 	call	0x762	; 0x762 <display>
 82a:	16 c0       	rjmp	.+44     	; 0x858 <display_multiplex+0x3c>
	else if (multiplex_counter == 1)
 82c:	81 30       	cpi	r24, 0x01	; 1
 82e:	21 f4       	brne	.+8      	; 0x838 <display_multiplex+0x1c>
	display(1, 2);
 830:	62 e0       	ldi	r22, 0x02	; 2
 832:	0e 94 b1 03 	call	0x762	; 0x762 <display>
 836:	10 c0       	rjmp	.+32     	; 0x858 <display_multiplex+0x3c>
	else if (multiplex_counter == 2)
 838:	82 30       	cpi	r24, 0x02	; 2
 83a:	21 f4       	brne	.+8      	; 0x844 <display_multiplex+0x28>
	display(2, 3);
 83c:	63 e0       	ldi	r22, 0x03	; 3
 83e:	0e 94 b1 03 	call	0x762	; 0x762 <display>
 842:	0a c0       	rjmp	.+20     	; 0x858 <display_multiplex+0x3c>
	else if (multiplex_counter == 3)
 844:	83 30       	cpi	r24, 0x03	; 3
 846:	21 f4       	brne	.+8      	; 0x850 <display_multiplex+0x34>
	display(3, 4);
 848:	64 e0       	ldi	r22, 0x04	; 4
 84a:	0e 94 b1 03 	call	0x762	; 0x762 <display>
 84e:	04 c0       	rjmp	.+8      	; 0x858 <display_multiplex+0x3c>
	else if (multiplex_counter == 4)
 850:	84 30       	cpi	r24, 0x04	; 4
 852:	11 f4       	brne	.+4      	; 0x858 <display_multiplex+0x3c>
	clearDisplay();
 854:	0e 94 a4 03 	call	0x748	; 0x748 <clearDisplay>

	multiplex_counter++;
 858:	20 91 10 01 	lds	r18, 0x0110
 85c:	2f 5f       	subi	r18, 0xFF	; 255
 85e:	20 93 10 01 	sts	0x0110, r18

	// brightness setting: 5~100
	if (multiplex_counter == brightness) multiplex_counter = 0;
 862:	30 e0       	ldi	r19, 0x00	; 0
 864:	80 91 0a 01 	lds	r24, 0x010A
 868:	90 91 0b 01 	lds	r25, 0x010B
 86c:	28 17       	cp	r18, r24
 86e:	39 07       	cpc	r19, r25
 870:	11 f4       	brne	.+4      	; 0x876 <display_multiplex+0x5a>
 872:	10 92 10 01 	sts	0x0110, r1
 876:	08 95       	ret

00000878 <__vector_16>:
}

// run once every 1 us
ISR(TIMER0_OVF_vect)
{
 878:	1f 92       	push	r1
 87a:	0f 92       	push	r0
 87c:	0f b6       	in	r0, 0x3f	; 63
 87e:	0f 92       	push	r0
 880:	11 24       	eor	r1, r1
 882:	2f 93       	push	r18
 884:	3f 93       	push	r19
 886:	4f 93       	push	r20
 888:	5f 93       	push	r21
 88a:	6f 93       	push	r22
 88c:	7f 93       	push	r23
 88e:	8f 93       	push	r24
 890:	9f 93       	push	r25
 892:	af 93       	push	r26
 894:	bf 93       	push	r27
 896:	ef 93       	push	r30
 898:	ff 93       	push	r31
	display_multiplex();
 89a:	0e 94 0e 04 	call	0x81c	; 0x81c <display_multiplex>
	TCNT0 = 0xFF - 10; // Overflow again after 10 ticks = 10 us
 89e:	85 ef       	ldi	r24, 0xF5	; 245
 8a0:	86 bd       	out	0x26, r24	; 38
}
 8a2:	ff 91       	pop	r31
 8a4:	ef 91       	pop	r30
 8a6:	bf 91       	pop	r27
 8a8:	af 91       	pop	r26
 8aa:	9f 91       	pop	r25
 8ac:	8f 91       	pop	r24
 8ae:	7f 91       	pop	r23
 8b0:	6f 91       	pop	r22
 8b2:	5f 91       	pop	r21
 8b4:	4f 91       	pop	r20
 8b6:	3f 91       	pop	r19
 8b8:	2f 91       	pop	r18
 8ba:	0f 90       	pop	r0
 8bc:	0f be       	out	0x3f, r0	; 63
 8be:	0f 90       	pop	r0
 8c0:	1f 90       	pop	r1
 8c2:	18 95       	reti

000008c4 <EncoderInit>:

//=========================================== инициализация экодера =======================
//Инициализация энкодера
void EncoderInit(void)
{
	EncoderDDR &= ~(EncoderF1 | EncoderF2); //настройка портов на ввод
 8c4:	8a b1       	in	r24, 0x0a	; 10
 8c6:	8a 7f       	andi	r24, 0xFA	; 250
 8c8:	8a b9       	out	0x0a, r24	; 10
	EncoderPORT |= EncoderF1 | EncoderF2;   //включение подтягивающих резисторов
 8ca:	8b b1       	in	r24, 0x0b	; 11
 8cc:	85 60       	ori	r24, 0x05	; 5
 8ce:	8b b9       	out	0x0b, r24	; 11
	EncPrev = State0;                       //инициализация предыдущего состояния
 8d0:	10 92 1a 01 	sts	0x011A, r1
	EncPrevPrev = State0;                   //инициализация пред-предыдущего состояния
 8d4:	10 92 19 01 	sts	0x0119, r1
 8d8:	08 95       	ret

000008da <To_Do_Step_Up>:
//===========================================================================
//=======================================    =================================
void To_Do_Step_Up()
{
	
	if(EncoderValue<MAX_VOLT10 && flag == FALCE) EncoderValue+=10;
 8da:	80 91 1b 01 	lds	r24, 0x011B
 8de:	90 91 1c 01 	lds	r25, 0x011C
 8e2:	8a 3f       	cpi	r24, 0xFA	; 250
 8e4:	91 05       	cpc	r25, r1
 8e6:	48 f4       	brcc	.+18     	; 0x8fa <To_Do_Step_Up+0x20>
 8e8:	20 91 bb 02 	lds	r18, 0x02BB
 8ec:	21 11       	cpse	r18, r1
 8ee:	05 c0       	rjmp	.+10     	; 0x8fa <To_Do_Step_Up+0x20>
 8f0:	0a 96       	adiw	r24, 0x0a	; 10
 8f2:	90 93 1c 01 	sts	0x011C, r25
 8f6:	80 93 1b 01 	sts	0x011B, r24
	 if(EncoderValue<MAX_VOLT && flag == TRUE) EncoderValue++;
 8fa:	80 91 1b 01 	lds	r24, 0x011B
 8fe:	90 91 1c 01 	lds	r25, 0x011C
 902:	8f 3f       	cpi	r24, 0xFF	; 255
 904:	91 05       	cpc	r25, r1
 906:	48 f4       	brcc	.+18     	; 0x91a <__stack+0x1b>
 908:	20 91 bb 02 	lds	r18, 0x02BB
 90c:	21 30       	cpi	r18, 0x01	; 1
 90e:	29 f4       	brne	.+10     	; 0x91a <__stack+0x1b>
 910:	01 96       	adiw	r24, 0x01	; 1
 912:	90 93 1c 01 	sts	0x011C, r25
 916:	80 93 1b 01 	sts	0x011B, r24
 91a:	08 95       	ret

0000091c <To_Do_Step_Dn>:
	
}
void To_Do_Step_Dn()
{
	
	if(EncoderValue > MIN_VOLT && flag == FALCE) EncoderValue-=10 ;
 91c:	80 91 1b 01 	lds	r24, 0x011B
 920:	90 91 1c 01 	lds	r25, 0x011C
 924:	00 97       	sbiw	r24, 0x00	; 0
 926:	a1 f0       	breq	.+40     	; 0x950 <To_Do_Step_Dn+0x34>
 928:	20 91 bb 02 	lds	r18, 0x02BB
 92c:	21 11       	cpse	r18, r1
 92e:	07 c0       	rjmp	.+14     	; 0x93e <To_Do_Step_Dn+0x22>
 930:	0a 97       	sbiw	r24, 0x0a	; 10
 932:	90 93 1c 01 	sts	0x011C, r25
 936:	80 93 1b 01 	sts	0x011B, r24
	 if(EncoderValue > MIN_VOLT && flag == TRUE) EncoderValue--;
 93a:	00 97       	sbiw	r24, 0x00	; 0
 93c:	49 f0       	breq	.+18     	; 0x950 <To_Do_Step_Dn+0x34>
 93e:	20 91 bb 02 	lds	r18, 0x02BB
 942:	21 30       	cpi	r18, 0x01	; 1
 944:	29 f4       	brne	.+10     	; 0x950 <To_Do_Step_Dn+0x34>
 946:	01 97       	sbiw	r24, 0x01	; 1
 948:	90 93 1c 01 	sts	0x011C, r25
 94c:	80 93 1b 01 	sts	0x011B, r24
 950:	08 95       	ret

00000952 <EncoderExe>:
}
//=============================================================================================
//================================== Функция обработки энкодера ========================
//Обработка энкодера
void EncoderExe(void)
{
 952:	cf 93       	push	r28
 954:	df 93       	push	r29
	char EncCur = 0;

	if(! (EncoderPIN & EncoderF1))
 956:	c9 b1       	in	r28, 0x09	; 9
 958:	c0 95       	com	r28
 95a:	c1 70       	andi	r28, 0x01	; 1
	EncCur  = StateA; //опрос фазы 1 энкодера

	if(! (EncoderPIN & EncoderF2))
 95c:	4a 9b       	sbis	0x09, 2	; 9
	EncCur |= StateB; //опрос фазы 2 энкодера
 95e:	c2 60       	ori	r28, 0x02	; 2

	if(EncCur != EncPrev) {                    //если состояние изменилось,
 960:	d0 91 1a 01 	lds	r29, 0x011A
 964:	cd 17       	cp	r28, r29
 966:	89 f0       	breq	.+34     	; 0x98a <EncoderExe+0x38>
		if(EncPrev == StateAB && EncCur != EncPrevPrev ){//если предыдущее состояние StateAB и текущее и пред-предыдущее не равны,
 968:	d3 30       	cpi	r29, 0x03	; 3
 96a:	59 f4       	brne	.+22     	; 0x982 <EncoderExe+0x30>
 96c:	80 91 19 01 	lds	r24, 0x0119
 970:	c8 17       	cp	r28, r24
 972:	39 f0       	breq	.+14     	; 0x982 <EncoderExe+0x30>
			if(EncCur == StateB) 
 974:	c2 30       	cpi	r28, 0x02	; 2
 976:	19 f4       	brne	.+6      	; 0x97e <EncoderExe+0x2c>
			{ 
				
				 To_Do_Step_Up();
 978:	0e 94 6d 04 	call	0x8da	; 0x8da <To_Do_Step_Up>
 97c:	02 c0       	rjmp	.+4      	; 0x982 <EncoderExe+0x30>
			
			else
			{
				            //шаг вниз
				
				To_Do_Step_Dn();
 97e:	0e 94 8e 04 	call	0x91c	; 0x91c <To_Do_Step_Dn>
			}
			
			
		}
		EncPrevPrev = EncPrev;              //сохранение пред-предыдущего состояния
 982:	d0 93 19 01 	sts	0x0119, r29
		EncPrev = EncCur;                   //сохранение предыдущего состояния
 986:	c0 93 1a 01 	sts	0x011A, r28
	}
}
 98a:	df 91       	pop	r29
 98c:	cf 91       	pop	r28
 98e:	08 95       	ret

00000990 <main>:

//===================================================================================================================
int main (void)
{
	// Порты ввода/вывода
	DDRB = 0xFF; // Выходы
 990:	8f ef       	ldi	r24, 0xFF	; 255
 992:	84 b9       	out	0x04, r24	; 4
	PORTB = 0x00;
 994:	15 b8       	out	0x05, r1	; 5
	DDRD |=  (1 << LED_STATUS) | (1 << RELAY_K9); // Входы //PD6 PD7 LED_STATUS Выходы
 996:	8a b1       	in	r24, 0x0a	; 10
 998:	80 6a       	ori	r24, 0xA0	; 160
 99a:	8a b9       	out	0x0a, r24	; 10
//	MCUCR |= (1 << ISC01); // Прерывание по заднему фронту INT0(по спаду импульса)
//	EIFR |= (1 << INTF0); // Очищаем флаг внешнего прерывания
//	EIMSK |= (1 << INT0);  // Разрешаем внешние прерывания INT0
	
	//===========================настройка таймера на прерывание с частотой 100Гц=====================
	OCR2A = F_CPU / 1024 / 100;					//формула для получения частоты 100Гц
 99c:	8e e4       	ldi	r24, 0x4E	; 78
 99e:	80 93 b3 00 	sts	0x00B3, r24
	TIMSK2 |= (1<<OCIE2A);						//прерывание при совпадении
 9a2:	e0 e7       	ldi	r30, 0x70	; 112
 9a4:	f0 e0       	ldi	r31, 0x00	; 0
 9a6:	80 81       	ld	r24, Z
 9a8:	82 60       	ori	r24, 0x02	; 2
 9aa:	80 83       	st	Z, r24
	TCCR2B = (1<<CS22)| (1<<CS21)| (1<<CS20);	//предделитель на 1024
 9ac:	87 e0       	ldi	r24, 0x07	; 7
 9ae:	80 93 b1 00 	sts	0x00B1, r24
	TCCR2A = (1<<WGM21)| (0<<WGM20);				//режим CTC (сброс при совпадении)
 9b2:	82 e0       	ldi	r24, 0x02	; 2
 9b4:	80 93 b0 00 	sts	0x00B0, r24
	//=========================================
	Timer_init();
 9b8:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <Timer_init>
	EncoderInit();
 9bc:	0e 94 62 04 	call	0x8c4	; 0x8c4 <EncoderInit>
	Adc_rms_init();
 9c0:	0e 94 3a 02 	call	0x474	; 0x474 <Adc_rms_init>
	fn_SetMeas();
 9c4:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <fn_SetMeas>
	BtnInit();
 9c8:	0e 94 f6 02 	call	0x5ec	; 0x5ec <BtnInit>
	Urms = 0;
 9cc:	10 92 17 01 	sts	0x0117, r1
 9d0:	10 92 16 01 	sts	0x0116, r1
	sei(); // Глобально разрешаем прерывания
 9d4:	78 94       	sei
	
	while(1)
	{
		
		 
		if(!sMeasure.cReady)
 9d6:	c0 eb       	ldi	r28, 0xB0	; 176
 9d8:	d2 e0       	ldi	r29, 0x02	; 2

		{
			//Rashet_rms();
			sMeasure.iRez= fn_Calculate();
 9da:	0f 2e       	mov	r0, r31
 9dc:	fe ea       	ldi	r31, 0xAE	; 174
 9de:	cf 2e       	mov	r12, r31
 9e0:	f2 e0       	ldi	r31, 0x02	; 2
 9e2:	df 2e       	mov	r13, r31
 9e4:	f0 2d       	mov	r31, r0
			lRez_long=(unsigned long)sMeasure.iRez * U_OPORN;
			lRez_long*=KF;
			lRez_long+=512; // снижаем ошибку целочисленного деления
			lRez_long/=1024; // делим в последнюю очередь
			lRez_long+=500;// снижаем ошибку целочисленного деления
			Urms=(unsigned int)(lRez_long/1000); // переводим в вольты
 9e6:	0f 2e       	mov	r0, r31
 9e8:	f8 ee       	ldi	r31, 0xE8	; 232
 9ea:	8f 2e       	mov	r8, r31
 9ec:	f3 e0       	ldi	r31, 0x03	; 3
 9ee:	9f 2e       	mov	r9, r31
 9f0:	a1 2c       	mov	r10, r1
 9f2:	b1 2c       	mov	r11, r1
 9f4:	f0 2d       	mov	r31, r0
			switch(button) {
				
		case 1:	 PORTD |= (1 << LED_STATUS); // 
			 PORTD |= (1 << RELAY_K9);
			// clear_screen();
			 TIMSK1 &=~ (1<<TOIE1);//Выключение АЦП
 9f6:	0f 2e       	mov	r0, r31
 9f8:	ff e6       	ldi	r31, 0x6F	; 111
 9fa:	4f 2e       	mov	r4, r31
 9fc:	51 2c       	mov	r5, r1
 9fe:	f0 2d       	mov	r31, r0
			 flag = FALCE;
			
			EncoderExe();
			
			 voltage_v =  EncoderValue;
 a00:	0f 2e       	mov	r0, r31
 a02:	fb e1       	ldi	r31, 0x1B	; 27
 a04:	ef 2e       	mov	r14, r31
 a06:	f1 e0       	ldi	r31, 0x01	; 1
 a08:	ff 2e       	mov	r15, r31
 a0a:	f0 2d       	mov	r31, r0
		if (button1 == BTN_SHRT2)
		{
			//PORTD |= (1 << PD7);
			//button++;
			if(button++>= 2) {
			 button = 1;
 a0c:	77 24       	eor	r7, r7
 a0e:	73 94       	inc	r7
	
	while(1)
	{
		
		 
		if(!sMeasure.cReady)
 a10:	88 81       	ld	r24, Y
 a12:	81 11       	cpse	r24, r1
 a14:	3d c0       	rjmp	.+122    	; 0xa90 <main+0x100>

		{
			//Rashet_rms();
			sMeasure.iRez= fn_Calculate();
 a16:	0e 94 c8 02 	call	0x590	; 0x590 <fn_Calculate>
 a1a:	f6 01       	movw	r30, r12
 a1c:	91 83       	std	Z+1, r25	; 0x01
 a1e:	80 83       	st	Z, r24
			lRez_long=(unsigned long)sMeasure.iRez * U_OPORN;
 a20:	a0 81       	ld	r26, Z
 a22:	b1 81       	ldd	r27, Z+1	; 0x01
			lRez_long*=KF;
 a24:	28 e9       	ldi	r18, 0x98	; 152
 a26:	3e ef       	ldi	r19, 0xFE	; 254
 a28:	49 e0       	ldi	r20, 0x09	; 9
 a2a:	50 e0       	ldi	r21, 0x00	; 0
 a2c:	0e 94 38 06 	call	0xc70	; 0xc70 <__muluhisi3>
			lRez_long+=512; // снижаем ошибку целочисленного деления
 a30:	dc 01       	movw	r26, r24
 a32:	cb 01       	movw	r24, r22
 a34:	9e 5f       	subi	r25, 0xFE	; 254
 a36:	af 4f       	sbci	r26, 0xFF	; 255
 a38:	bf 4f       	sbci	r27, 0xFF	; 255
			lRez_long/=1024; // делим в последнюю очередь
 a3a:	07 2e       	mov	r0, r23
 a3c:	7a e0       	ldi	r23, 0x0A	; 10
 a3e:	b6 95       	lsr	r27
 a40:	a7 95       	ror	r26
 a42:	97 95       	ror	r25
 a44:	87 95       	ror	r24
 a46:	7a 95       	dec	r23
 a48:	d1 f7       	brne	.-12     	; 0xa3e <main+0xae>
 a4a:	70 2d       	mov	r23, r0
			lRez_long+=500;// снижаем ошибку целочисленного деления
 a4c:	bc 01       	movw	r22, r24
 a4e:	cd 01       	movw	r24, r26
 a50:	6c 50       	subi	r22, 0x0C	; 12
 a52:	7e 4f       	sbci	r23, 0xFE	; 254
 a54:	8f 4f       	sbci	r24, 0xFF	; 255
 a56:	9f 4f       	sbci	r25, 0xFF	; 255
 a58:	60 93 12 01 	sts	0x0112, r22
 a5c:	70 93 13 01 	sts	0x0113, r23
 a60:	80 93 14 01 	sts	0x0114, r24
 a64:	90 93 15 01 	sts	0x0115, r25
			Urms=(unsigned int)(lRez_long/1000); // переводим в вольты
 a68:	a5 01       	movw	r20, r10
 a6a:	94 01       	movw	r18, r8
 a6c:	0e 94 01 06 	call	0xc02	; 0xc02 <__udivmodsi4>
 a70:	30 93 17 01 	sts	0x0117, r19
 a74:	20 93 16 01 	sts	0x0116, r18
			
			//set_number(Urms);//   вывод значения в вольтах АЦП
			//set_char_at('U', 0);//вывод символа в оределенное знакоместо
			indication(Urms, 0x62);
 a78:	62 e6       	ldi	r22, 0x62	; 98
 a7a:	c9 01       	movw	r24, r18
 a7c:	0e 94 44 01 	call	0x288	; 0x288 <indication>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 a80:	8f e1       	ldi	r24, 0x1F	; 31
 a82:	9e e4       	ldi	r25, 0x4E	; 78
 a84:	01 97       	sbiw	r24, 0x01	; 1
 a86:	f1 f7       	brne	.-4      	; 0xa84 <main+0xf4>
 a88:	00 c0       	rjmp	.+0      	; 0xa8a <main+0xfa>
 a8a:	00 00       	nop
			//
			_delay_ms(10);
			
			fn_SetMeas();
 a8c:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <fn_SetMeas>
		}
		
		uint8_t button1 = BtnGet();
 a90:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <BtnGet>
 a94:	18 2f       	mov	r17, r24
		//if((PIND & (1 << BUTTON_ENC)) == 0) // Если нажата кнопка энкодера
		if (button1 == BTN_SHRT2)
 a96:	82 30       	cpi	r24, 0x02	; 2
 a98:	51 f4       	brne	.+20     	; 0xaae <main+0x11e>
		{
			//PORTD |= (1 << PD7);
			//button++;
			if(button++>= 2) {
 a9a:	80 91 18 01 	lds	r24, 0x0118
 a9e:	91 e0       	ldi	r25, 0x01	; 1
 aa0:	98 0f       	add	r25, r24
 aa2:	90 93 18 01 	sts	0x0118, r25
 aa6:	82 30       	cpi	r24, 0x02	; 2
 aa8:	10 f0       	brcs	.+4      	; 0xaae <main+0x11e>
			 button = 1;
 aaa:	70 92 18 01 	sts	0x0118, r7
			 
			}
		}
			//while((PIND & (1 << BUTTON_ENC)) == 0){} // Ждем отпускания кнопки
			//_delay_ms(50);
			switch(button) {
 aae:	80 91 18 01 	lds	r24, 0x0118
 ab2:	81 30       	cpi	r24, 0x01	; 1
 ab4:	19 f0       	breq	.+6      	; 0xabc <main+0x12c>
 ab6:	82 30       	cpi	r24, 0x02	; 2
 ab8:	f1 f0       	breq	.+60     	; 0xaf6 <main+0x166>
 aba:	32 c0       	rjmp	.+100    	; 0xb20 <main+0x190>
				
		case 1:	 PORTD |= (1 << LED_STATUS); // 
 abc:	5d 9a       	sbi	0x0b, 5	; 11
			 PORTD |= (1 << RELAY_K9);
 abe:	5f 9a       	sbi	0x0b, 7	; 11
			// clear_screen();
			 TIMSK1 &=~ (1<<TOIE1);//Выключение АЦП
 ac0:	f2 01       	movw	r30, r4
 ac2:	80 81       	ld	r24, Z
 ac4:	8e 7f       	andi	r24, 0xFE	; 254
 ac6:	80 83       	st	Z, r24
			 flag = FALCE;
 ac8:	10 92 bb 02 	sts	0x02BB, r1
			
			EncoderExe();
 acc:	0e 94 a9 04 	call	0x952	; 0x952 <EncoderExe>
			
			 voltage_v =  EncoderValue;
 ad0:	f7 01       	movw	r30, r14
 ad2:	80 81       	ld	r24, Z
 ad4:	80 93 ba 02 	sts	0x02BA, r24
			 if(voltage_v > 255) EncoderValue = 255;
 ad8:	80 91 ba 02 	lds	r24, 0x02BA
				indication(voltage_v, 0xf3);
 adc:	80 91 ba 02 	lds	r24, 0x02BA
 ae0:	63 ef       	ldi	r22, 0xF3	; 243
 ae2:	90 e0       	ldi	r25, 0x00	; 0
 ae4:	0e 94 44 01 	call	0x288	; 0x288 <indication>
 ae8:	8f e1       	ldi	r24, 0x1F	; 31
 aea:	9e e4       	ldi	r25, 0x4E	; 78
 aec:	01 97       	sbiw	r24, 0x01	; 1
 aee:	f1 f7       	brne	.-4      	; 0xaec <main+0x15c>
 af0:	00 c0       	rjmp	.+0      	; 0xaf2 <main+0x162>
 af2:	00 00       	nop
 af4:	15 c0       	rjmp	.+42     	; 0xb20 <main+0x190>
			//button = 0;
			break;		
			
			//else PORTD &= ~(1 << PD7);
		case 2:
			 PORTD &=~ (1 << LED_STATUS); //
 af6:	5d 98       	cbi	0x0b, 5	; 11
			 flag = TRUE;
 af8:	70 92 bb 02 	sts	0x02BB, r7
			 
			EncoderExe();
 afc:	0e 94 a9 04 	call	0x952	; 0x952 <EncoderExe>
			 voltage_v =  EncoderValue;
 b00:	f7 01       	movw	r30, r14
 b02:	80 81       	ld	r24, Z
 b04:	80 93 ba 02 	sts	0x02BA, r24
			 indication(voltage_v, 0xf3);
 b08:	80 91 ba 02 	lds	r24, 0x02BA
 b0c:	63 ef       	ldi	r22, 0xF3	; 243
 b0e:	90 e0       	ldi	r25, 0x00	; 0
 b10:	0e 94 44 01 	call	0x288	; 0x288 <indication>
 b14:	8f e1       	ldi	r24, 0x1F	; 31
 b16:	9e e4       	ldi	r25, 0x4E	; 78
 b18:	01 97       	sbiw	r24, 0x01	; 1
 b1a:	f1 f7       	brne	.-4      	; 0xb18 <main+0x188>
 b1c:	00 c0       	rjmp	.+0      	; 0xb1e <main+0x18e>
 b1e:	00 00       	nop
			break;
			default:
			break;
			}
		
			if (button1 == BTN_LONG2)
 b20:	10 32       	cpi	r17, 0x20	; 32
 b22:	09 f0       	breq	.+2      	; 0xb26 <main+0x196>
 b24:	75 cf       	rjmp	.-278    	; 0xa10 <main+0x80>
			{
				
				PORTD &=~(1 << LED_STATUS);
 b26:	5d 98       	cbi	0x0b, 5	; 11
				flag =FALCE;
 b28:	10 92 bb 02 	sts	0x02BB, r1
				
				indication(voltage_v,0x60);
 b2c:	80 91 ba 02 	lds	r24, 0x02BA
 b30:	60 e6       	ldi	r22, 0x60	; 96
 b32:	90 e0       	ldi	r25, 0x00	; 0
 b34:	0e 94 44 01 	call	0x288	; 0x288 <indication>
				//voltage_v = 255;
				PORTB = voltage_v;
 b38:	80 91 ba 02 	lds	r24, 0x02BA
 b3c:	85 b9       	out	0x05, r24	; 5
 b3e:	9f ef       	ldi	r25, 0xFF	; 255
 b40:	ed e3       	ldi	r30, 0x3D	; 61
 b42:	f9 e4       	ldi	r31, 0x49	; 73
 b44:	91 50       	subi	r25, 0x01	; 1
 b46:	e0 40       	sbci	r30, 0x00	; 0
 b48:	f0 40       	sbci	r31, 0x00	; 0
 b4a:	e1 f7       	brne	.-8      	; 0xb44 <main+0x1b4>
 b4c:	00 c0       	rjmp	.+0      	; 0xb4e <main+0x1be>
 b4e:	00 00       	nop
				_delay_ms(3000);
				PORTD &=~(1 << RELAY_K9);
 b50:	5f 98       	cbi	0x0b, 7	; 11
				TIMSK1 |= (1<<TOIE1);//запуск АЦП
 b52:	f2 01       	movw	r30, r4
 b54:	80 81       	ld	r24, Z
 b56:	81 60       	ori	r24, 0x01	; 1
 b58:	80 83       	st	Z, r24
				indication(Urms, 0x62);
 b5a:	62 e6       	ldi	r22, 0x62	; 98
 b5c:	80 91 16 01 	lds	r24, 0x0116
 b60:	90 91 17 01 	lds	r25, 0x0117
 b64:	0e 94 44 01 	call	0x288	; 0x288 <indication>
			button = 0;
 b68:	10 92 18 01 	sts	0x0118, r1
 b6c:	ff ef       	ldi	r31, 0xFF	; 255
 b6e:	20 e7       	ldi	r18, 0x70	; 112
 b70:	82 e0       	ldi	r24, 0x02	; 2
 b72:	f1 50       	subi	r31, 0x01	; 1
 b74:	20 40       	sbci	r18, 0x00	; 0
 b76:	80 40       	sbci	r24, 0x00	; 0
 b78:	e1 f7       	brne	.-8      	; 0xb72 <main+0x1e2>
 b7a:	00 c0       	rjmp	.+0      	; 0xb7c <main+0x1ec>
 b7c:	00 00       	nop
 b7e:	48 cf       	rjmp	.-368    	; 0xa10 <main+0x80>

00000b80 <__vector_7>:
		
	}//  while
}// main

ISR (TIMER2_COMPA_vect)							//interrupt 100hz
{
 b80:	1f 92       	push	r1
 b82:	0f 92       	push	r0
 b84:	0f b6       	in	r0, 0x3f	; 63
 b86:	0f 92       	push	r0
 b88:	11 24       	eor	r1, r1
 b8a:	2f 93       	push	r18
 b8c:	3f 93       	push	r19
 b8e:	4f 93       	push	r20
 b90:	5f 93       	push	r21
 b92:	6f 93       	push	r22
 b94:	7f 93       	push	r23
 b96:	8f 93       	push	r24
 b98:	9f 93       	push	r25
 b9a:	af 93       	push	r26
 b9c:	bf 93       	push	r27
 b9e:	ef 93       	push	r30
 ba0:	ff 93       	push	r31
	BtnExe();
 ba2:	0e 94 01 03 	call	0x602	; 0x602 <BtnExe>
	//PORTD ^=( 1 << LED_STATUS );
}
 ba6:	ff 91       	pop	r31
 ba8:	ef 91       	pop	r30
 baa:	bf 91       	pop	r27
 bac:	af 91       	pop	r26
 bae:	9f 91       	pop	r25
 bb0:	8f 91       	pop	r24
 bb2:	7f 91       	pop	r23
 bb4:	6f 91       	pop	r22
 bb6:	5f 91       	pop	r21
 bb8:	4f 91       	pop	r20
 bba:	3f 91       	pop	r19
 bbc:	2f 91       	pop	r18
 bbe:	0f 90       	pop	r0
 bc0:	0f be       	out	0x3f, r0	; 63
 bc2:	0f 90       	pop	r0
 bc4:	1f 90       	pop	r1
 bc6:	18 95       	reti

00000bc8 <Timer_init>:
#include "ADC.h"

void Timer_init()
{
	
TCCR1A=0x00;
 bc8:	10 92 80 00 	sts	0x0080, r1
TCCR1B=0x01;//       CS10=1
 bcc:	81 e0       	ldi	r24, 0x01	; 1
 bce:	80 93 81 00 	sts	0x0081, r24
//TCNT1=TMR1_CALCULATE;
TCNT1=0xfce0;
 bd2:	80 ee       	ldi	r24, 0xE0	; 224
 bd4:	9c ef       	ldi	r25, 0xFC	; 252
 bd6:	90 93 85 00 	sts	0x0085, r25
 bda:	80 93 84 00 	sts	0x0084, r24
//TCNT1L=0x00;
ICR1H=0x00;
 bde:	10 92 87 00 	sts	0x0087, r1
ICR1L=0x00;
 be2:	10 92 86 00 	sts	0x0086, r1
OCR1AH=0x00;
 be6:	10 92 89 00 	sts	0x0089, r1
OCR1AL=0x00;
 bea:	10 92 88 00 	sts	0x0088, r1
OCR1BH=0x00;
 bee:	10 92 8b 00 	sts	0x008B, r1
OCR1BL=0x00;
 bf2:	10 92 8a 00 	sts	0x008A, r1

// Timer(s)/Counter(s) Interrupt(s) initialization

TIMSK1 |= (1<<TOIE1); // Enable Overflow Interrupt Enable
 bf6:	ef e6       	ldi	r30, 0x6F	; 111
 bf8:	f0 e0       	ldi	r31, 0x00	; 0
 bfa:	80 81       	ld	r24, Z
 bfc:	81 60       	ori	r24, 0x01	; 1
 bfe:	80 83       	st	Z, r24
 c00:	08 95       	ret

00000c02 <__udivmodsi4>:
 c02:	a1 e2       	ldi	r26, 0x21	; 33
 c04:	1a 2e       	mov	r1, r26
 c06:	aa 1b       	sub	r26, r26
 c08:	bb 1b       	sub	r27, r27
 c0a:	fd 01       	movw	r30, r26
 c0c:	0d c0       	rjmp	.+26     	; 0xc28 <__udivmodsi4_ep>

00000c0e <__udivmodsi4_loop>:
 c0e:	aa 1f       	adc	r26, r26
 c10:	bb 1f       	adc	r27, r27
 c12:	ee 1f       	adc	r30, r30
 c14:	ff 1f       	adc	r31, r31
 c16:	a2 17       	cp	r26, r18
 c18:	b3 07       	cpc	r27, r19
 c1a:	e4 07       	cpc	r30, r20
 c1c:	f5 07       	cpc	r31, r21
 c1e:	20 f0       	brcs	.+8      	; 0xc28 <__udivmodsi4_ep>
 c20:	a2 1b       	sub	r26, r18
 c22:	b3 0b       	sbc	r27, r19
 c24:	e4 0b       	sbc	r30, r20
 c26:	f5 0b       	sbc	r31, r21

00000c28 <__udivmodsi4_ep>:
 c28:	66 1f       	adc	r22, r22
 c2a:	77 1f       	adc	r23, r23
 c2c:	88 1f       	adc	r24, r24
 c2e:	99 1f       	adc	r25, r25
 c30:	1a 94       	dec	r1
 c32:	69 f7       	brne	.-38     	; 0xc0e <__udivmodsi4_loop>
 c34:	60 95       	com	r22
 c36:	70 95       	com	r23
 c38:	80 95       	com	r24
 c3a:	90 95       	com	r25
 c3c:	9b 01       	movw	r18, r22
 c3e:	ac 01       	movw	r20, r24
 c40:	bd 01       	movw	r22, r26
 c42:	cf 01       	movw	r24, r30
 c44:	08 95       	ret

00000c46 <__tablejump2__>:
 c46:	ee 0f       	add	r30, r30
 c48:	ff 1f       	adc	r31, r31

00000c4a <__tablejump__>:
 c4a:	05 90       	lpm	r0, Z+
 c4c:	f4 91       	lpm	r31, Z
 c4e:	e0 2d       	mov	r30, r0
 c50:	09 94       	ijmp

00000c52 <__umulhisi3>:
 c52:	a2 9f       	mul	r26, r18
 c54:	b0 01       	movw	r22, r0
 c56:	b3 9f       	mul	r27, r19
 c58:	c0 01       	movw	r24, r0
 c5a:	a3 9f       	mul	r26, r19
 c5c:	70 0d       	add	r23, r0
 c5e:	81 1d       	adc	r24, r1
 c60:	11 24       	eor	r1, r1
 c62:	91 1d       	adc	r25, r1
 c64:	b2 9f       	mul	r27, r18
 c66:	70 0d       	add	r23, r0
 c68:	81 1d       	adc	r24, r1
 c6a:	11 24       	eor	r1, r1
 c6c:	91 1d       	adc	r25, r1
 c6e:	08 95       	ret

00000c70 <__muluhisi3>:
 c70:	0e 94 29 06 	call	0xc52	; 0xc52 <__umulhisi3>
 c74:	a5 9f       	mul	r26, r21
 c76:	90 0d       	add	r25, r0
 c78:	b4 9f       	mul	r27, r20
 c7a:	90 0d       	add	r25, r0
 c7c:	a4 9f       	mul	r26, r20
 c7e:	80 0d       	add	r24, r0
 c80:	91 1d       	adc	r25, r1
 c82:	11 24       	eor	r1, r1
 c84:	08 95       	ret

00000c86 <_exit>:
 c86:	f8 94       	cli

00000c88 <__stop_program>:
 c88:	ff cf       	rjmp	.-2      	; 0xc88 <__stop_program>
